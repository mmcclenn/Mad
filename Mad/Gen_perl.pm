#
# NBGC Project
# 
# Gen_perl.pm - Generate Perl code
# 
# Author: Michael McClennen
# Copyright (c) 2010 University of Wisconsin-Madison
# 
# The variables and routines in this file handle generation of Perl code.


package Mad::Model;

use Mad::Units;

use strict;
use warnings;

our(%SIGIL_MAP_PERL) = ('SCALARV' => '$', 'LISTV' => '@', 'SETV' => '%', 
		   'PVAR' => '$');

our (%PRIMITIVE_TYPE, %BASE_TYPE, %TYPE_SIGIL);

our (%OP_TRANS_PERL) = ('~' => '.', 
			'^' => '**');


# init_perl ( )
# 
# Prepare to generate Perl code.

sub init_perl {

    my ($self) = @_;
    
    # Create a name for the package into which all of this model's static
    # variables will be put.
    
    $self->{runpkg} = 'MadRun' . $RUNPKG . '::';
    $self->{runmain} = 'MadRun' . $RUNPKG;
    $RUNPKG++;
    
    # Choose the functions which will be used to generate target code
    
    $self->{expr_fun} = \&generate_expr_perl;
    $self->{trans_fun} = \&tr_type_perl;
    $self->{dim_fun} = \&dimension_perl;
    $self->{flow_fun} = \&flow2perl;
    
    

}


# generate_code_perl ( $objname )
# 
# Generate Perl code to express this model, and write it to the given object
# file.  Return true if this was done successfully, false otherwise.

sub generate_code_perl {

    my ($self, $objname) = @_;
    
    # If the output filename as given ends in ".mad" (i.e. it defaults to the
    # input file name) then transform it.
    
    if ( $objname ) {
	$objname =~ s/.mad$/-mpc.pl/;
    }
    
    $self->{objname} = $objname;
    
    # If errors occurred, just erase the output file.
    
    if ( $self->{error_count} > 0 ) {
	unlink $objname if $objname;
	return undef;
    }
    
    # Initialize the necessary variables.
    
    my $tree = $self->{parse_tree};
    my $rpkg = $self->{runpkg};
    my $code = "";
    
    # Then generate an outer context in which to define dynamic variables.
    # Blocks within the code will each be associated with their own context in
    # turn.
    
    my $context = Mad::Context->new($self);
    $context->{target} = 'perl';
    
    # Now generate the various parts of the code.  If any step generates an
    # error, we return immediately.
    
    # First the variables and statements that control the main step variable
    # $T.
    
    $self->generate_step_perl();
    if ( $self->{error_count} > 0 )
    {
	$self->{status} = 'LOAD_ERROR';
	return;
    }
    
    # Then the phases DECL, INIT, CALC, STEP and FINI.
    
    $self->generate_perl($tree, 'DEFAULT', 0, $context );
    if ( $self->{error_count} > 0 )
    {
	$self->{status} = 'LOAD_ERROR';
	return;
    }
    
    $self->close_dims_perl($context, 0);
    
    # Then, the code to carry out flows.  This is appended to the CALC phase
    # code.
    
    $self->generate_flow_perl($context);
    if ( $self->{error_count} > 0 )
    {
	$self->{status} = 'LOAD_ERROR';
	return;
    }
    
    # Finally, the code for recording the changing values of the variables,
    # a trace which will be used to generate output.
    
    $self->generate_trace_perl();
    if ( $self->{error_count} > 0 )
    {
	$self->{status} = 'LOAD_ERROR';
	return;
    }
    
    # Write each of these pieces of code to the output file.
    
    open(my $outfile, ">", $objname) || die "Could not write $objname: $!\n";
    
    print $outfile "\# Generated by madsim\n\n";
    print $outfile $self->{uses_code} . "\n\n";
    print $outfile "Mad::Runtime::run(\@ARGV) unless \$${rpkg}LOADING;\n";
    print $outfile "\n\# Variable declarations\n\n";
    print $outfile $self->{decl_code} . "\n";
    print $outfile "\n\# Structs, classes and functions\n\n";
    print $outfile $self->{func_code} . "\n";
    print $outfile "\n\# Phase and trace code\n\n";
    print $outfile "package $self->{runmain};\n\n";
    print $outfile "sub init_sub {\n" . $self->{init_code} . "}\n\n";
    print $outfile "sub calc_sub {\n" . $self->{calc_code} . "}\n\n";
    print $outfile "sub step_sub {\n" . $self->{step_code} . "}\n\n";
    print $outfile "sub fini_sub {\n" . $self->{fini_code} . "}\n\n";
    print $outfile "sub trac_sub {\n" . $self->{trac_code} . "}\n\n";
    print $outfile "sub dbgi_sub {\n" . $self->{dbgi_code} . "}\n\n";
    print $outfile "1;\n";
    
    close $outfile;
    
    return 1;
}


# generate_perl ( $node, $phase, $indent, $context )
# 
# Generate Perl code from the parse tree rooted at the given node, and place
# it by default into the given phase of the model at the given indentation level.
# This routine is responsible for parsing top-level syntactic constructs such
# as phase blocks, across blocks and flows, and calls generate_expr_perl to produce
# most of the actual code.
# 
# Note that in a Mad program, instead of there being one "main" function and
# other subsidiary routines called from it, the code is divided among four
# different "phases": INIT, CALC, STEP, and FINAL.  Each of these ends up as a
# separate function in the compiled code, such that INIT is run once, then
# CALC and STEP alternating for the duration of the run, then FINAL.  This is
# different from most (if not all) other programming languages.

sub generate_perl {
    
    my ($self, $node, $phase, $indent, $context) = @_;
    
    # Return immediately if we weren't actually given a real node.
    
    return unless ref $node;
    
    my $nt = ref $node;
    my $child = $node->{children};
    my $rpk = $self->{runpkg};
    my @context_stack;
    
    # The default phase is INIT
    
    $phase = 'INIT' if $phase eq 'DEFAULT';
    
    # Now, treat the node according to its type:
    
    # Nodes of type SOF represent the start of a new source file (from an
    # "include" directive), while EOF nodes represent the end of that file.
    # In order to handle file-scoped variables, we create a new context when
    # we get an SOF and put the current one on a stack.  When we get an EOF,
    # we pop the stack.
    
    #if ( $nt eq 'SOF' )
    #{
	# $$$ context stack must be global
	#push @context_stack, $context;
	#my $nc = $context->new($self);
    #}
    
    #elsif ( $nt eq 'EOF' )
    #{
	# $$$ context stack must be global, must make sure that the current
	# context (before pop) is the same as the one pushed at last SOF.
	#my $prev_context = pop @context_stack;
    #}
    
    # A "use" declaration needs to be added to the very first block.

    #els
    if ( $nt eq 'USE' )
    {
	$self->annotate('USES', 0, $node);
	$self->add_lines('USES', 0, "use $node->{attr};");
    }
    
    # The 'program sequence' nodes represent blocks.  PROGSEQ puts its
    # children into the current phase, while INIT, CALC, etc. put their
    # children specifically into the phase corresponding to their name.  In
    # all cases, we create a new context that is chained to the existing one.
    
    elsif ( $nt eq 'INIT' or $nt eq 'CALC' or $nt eq 'STEP' or $nt eq 'FINAL' or
	 $nt eq 'PROGSEQ' )
    {
	$phase = $nt unless $nt eq 'PROGSEQ';
	$self->close_dims_perl($context, $indent);
	my $nc = $context->new($self);
	$nc->{phase} = $phase;
	$self->add_lines($phase, $indent, '{') unless $indent == 0;
	foreach my $n ( @$child ) {
	    $self->generate_perl($n, $phase, $indent+1, $nc);
	}
	$self->close_dims_perl($nc, $indent+1);
	$self->add_lines($phase, $indent+$context->{dim_indent}, '}') unless $indent == 0;
    }
    
    elsif ( $nt eq 'FUNCTION' )
    {
	my $pkg = $self->{runmain};
	my $fname = $node->{attr};
	if ( $fname =~ /^(.*::)(\w+)$/ ) {
	    $pkg .= $1;
	    $fname = $2;
	}
	$self->add_lines('FUNC', 0, "package $pkg;");
	$self->add_lines('FUNC', 0, '');
	$self->generate_function_perl($node, $fname, '', $context);
    }
    
    elsif ( $nt eq 'METHOD' )
    {
	if ( $context->current_dims() > 0 )
	{
	    $self->syntax_error($node, "you can't define a method within a dimensional block");
	    return;
	}
	
	my $fname = $node->{attr};
	my ($class);
	if ( $fname =~ /(.*)::(.*)/ ) {
	    $class = $1;
	    $fname = $2;
	}
	else {
	    $self->syntax_error($node, "you must specify a class for this method");
	    return;
	}
	$self->add_lines('FUNC', 0, "package $self->{runpkg}$class;");
	$self->add_lines('FUNC', 0, '');
	$self->generate_function_perl($node, $fname, $class, $context);
    }
    
    elsif ( $nt eq 'CLASS' or $nt eq 'STRUCT' )
    {
	if ( $context->current_dims() > 0 )
	{
	    $self->syntax_error($node, "you can't define a class within a dimensional block");
	    return;
	}
	
	# First, create a Perl package for this class/struct in the
	# Mad::Gen namespace.  This is just for use in compilation, not for
	# the generated code.  This package will be used to call
	# _declare_code, _set_code, etc. and is always a subclass of
	# Mad::Gen::MadClass.
	
	my $ctype = $node->{attr};
	my $stmt = "package Mad::Gen::$ctype; \@Mad::Gen::${ctype}::ISA = ('Mad::Gen::MadClass');";
	eval $stmt || die "Could not eval 'package' statement: $@";
	
	# Second, generate code to create a Perl package for this class/struct
	# in the runtime namespace.  All of the class's methods will be
	# defined in this package.
	
	my $rpk = $self->{runpkg};
	$self->add_lines('FUNC', 0, "package $rpk$ctype;\n");
	
	# Create a new context linking to the symbol table for this class
	# (which was already created by declare_class() ).  This allows
	# attribute names to be used without qualification in any methods that
	# are contained in this declaration.
	
	my $class_rec = $self->lookup_static($ctype);
	$context = $context->new($self, $class_rec->{sym});
	$context->{phase} = 'FUNC';
	
	# Then we go through the children of this node, and collect up all of
	# the nodes representing attributes and methods for this class/struct.
	# We collect up functions named 'init' separately (there may be more
	# than one due to overloading (NOT IMPLEMENTED YET) because each of
	# these will automatically have a set of attribute initialization
	# statements placed at its beginning.
	
	my (@attr_nodes, @func_nodes, @init_nodes);
	
	foreach my $n ( @$child ) {
	    
	    if ( ref $n eq 'DECLARE' ) {
		push @attr_nodes, $n;
	    }
	    
	    elsif ( ref $n eq 'METHOD' ) {
		if ( $n->{attr} eq 'init' ) {
		    push @init_nodes, $n; 
		} else {
		    push @func_nodes, $n;
		}
	    }
	}
	
	# Now go through @attr_nodes and add a comment to document each field,
	# and for those which require initialization, an initialization line.
	
	my (@init_lines);
	
	foreach my $n ( @attr_nodes ) {
	    my $type_node = $n->{children}[-1];
	    my $type_name = $type_node->{attr};
	    my @na = $self->node_attributes($type_node);
	    foreach my $nn ( @{$n->{children}} ) {
		next if $nn == $type_node;
		my ($type, $subtype, $fulltype) =
		    $self->build_type($type_name, ref $nn);
		my $a_name = $nn->{attr};
		my $a_expr = '$this->{' . $a_name . '}';
		my @va = $self->node_attributes($nn);
		$self->add_lines('FUNC', 1, "\# $a_name : $type");
		my ($init_perl) = $type->_init_code($context, $nn, $subtype,
						    $a_expr, @na, @va);
		push @init_lines, $init_perl if defined $init_perl;
	    }
	}
	
	$self->add_lines('FUNC', 0, '');
	
	# Now go through @init_nodes, and generate an initialization function
	# from each.  (FOR NOW THERE SHOULD ONLY BE ONE).
	
	foreach my $n ( @init_nodes ) {
	    $self->generate_function_perl($n, 'init', $ctype,
					  $context, \@init_lines);
	}
	
	# If the user didn't specify an init function but there are
	# initialization lines that need to be executed, create an automatic
	# init function.
	
	if ( @init_nodes == 0 and @init_lines > 0 ) {
	    $self->generate_init_function_perl($ctype, \@init_lines);
	}
	
	# Then, through the other function nodes if any
	
	foreach my $n ( @func_nodes ) {
	    $self->generate_function_perl($n, $n->{attr}, $ctype,
					  $context);
	}
    }
    
    # Nodes that declare variables may generate both a declaration and an
    # initialization.
    
    # Variable declarations are handled by calling the _declare_code routine
    # from the corresponding package in the Mad::Gen:: namespace to generate
    # the necessary code.  This allows various object types to be declared in
    # whatever way they need to be.  Initialization is handled by calling the
    # _init_code routine.
    
    elsif ( $nt eq 'DECLARE' )
    {
	my $kind = $node->{kind};
	my $type_node = $child->[-1];
	my $type_name = $type_node->{attr};
	
	# Analyze the TYPE node, which is the last child of the DECLARE node.
	# Its children specify attributes which modify all variables declared
	# as children of the DECLARE node.
	
	my @attrs = $self->node_attributes($type_node);
	
	# and then the other children, each of which declares one variable.
	# The children of each of these nodes are attributes which modify the
	# individual variable.
	
	foreach my $n ( @$child ) 
	{
	    next if $n == $type_node;
	    
	    my ($var_name) = $n->{attr};
	    my ($var_type, $var_subtype, $var_fulltype) = 
		$self->build_type($type_name, ref $n);
	    my ($var_expr, $var_dim, $var_rec);
	    my (@init_perl);
	    
	    # If this variable is dynamic, we need to create a new
	    # variable-record for it and register it in the current context so
	    # that subsequent code can refer to it.  Otherwise, we look up the
	    # variable-record that already exists.
	    
	    if ( $kind eq 'DYN_VAR' )
	    {
		$var_expr = 'my ($' . $var_name . ')';
		$var_dim = $self->declare_dims($n->{children}[0]);
		$var_rec = { name => $var_name, kind => 'DYN_VAR', decl => $n,
			     type => $var_fulltype, dim => $var_dim };
		
		$context->define($var_name, $var_rec);
	    }
	    
	    else
	    {
		$var_expr = "\$$rpk$var_name";
		$var_rec = $self->lookup_static($var_name);
		$var_dim = $var_rec->{dim};
		
		#my ($decl_perl) = $var_type->_declare_code($context, $n, $var_subtype, 
		#					   $var_expr, $var_dim);
		#
		#$self->add_lines('DECL', 1, $decl_perl . ";    \# $var_type");
	    }
	    
	    # Now declare any named dimensions that have not yet been
	    # declared, and open loops for them.
	    
	    my $dim_count = 0;
	    my $dim_expr = '';
	    my $order_expr = '';
	    my (@loop_lines, @end_lines, @final_lines);
	    
	    if ( ref $var_dim eq 'ARRAY' and @$var_dim > 0 )
	    {
		$dim_expr = '->{dim}';
		
		foreach my $dim_rec ( @$var_dim )
		{
		    my $idx = "\$${rpk}_DIM_" . $dim_rec->{name};
		    my $di = '    ' x $dim_count;
		    $dim_expr .= "{$idx}";
		    $order_expr .= ', ' if $order_expr ne '';
		    
		    if ( $dim_rec->{select} eq 'setv' )
		    {
			unless ( $dim_rec->{declared} )
			{
			    my $dim_decl = "$idx;    \# index variable";
			    $self->add_lines('DECL', 1, $dim_decl);
			    $dim_rec->{declared} = 1;
			}
			
			my $setv_expr = "\$$rpk$dim_rec->{name}" . "->{values}";
			
			$order_expr .= $setv_expr;
			push @loop_lines, ($di . "foreach $idx (" . '@{' . 
					   $setv_expr . '})'), ($di . '{');
		    }
		    
		    elsif ( $dim_rec->{select} eq 'size' )
		    {
			$order_expr .= $dim_rec->{size};
			push @loop_lines, ($di . 
			    "foreach $idx (0.." . ($dim_rec->{size} - 1) . ")"),
				($di . '{');
		    }
		    
		    else # $dim_rec->{select} eq 'range'
		    {
			$order_expr .= "'$dim_rec->{start}:$dim_rec->{end}'";
			push @loop_lines, ($di .
			    "foreach $idx (" . $dim_rec->{start} . '..' .
				$dim_rec->{end} . ')'), ($di . '{');
		    }
		    
		    unshift @end_lines, $di . '}';
		    push @final_lines, "$idx = undef;";
		    $dim_count++;
		}
	    }
	    
	    # Now add any attributes associated with the node, and then create
	    # an initialization expression.
	    
	    my @nattrs = $self->node_attributes($n);
	    
	    my $init_expr = $var_type->_init_code($context, $n, $var_subtype, 
					$var_expr . $dim_expr, @attrs, @nattrs);
	    
	    # If the dimensionality is greater than zero, enclose the
	    # initialization expression in a loop and add a base
	    # initialization statement beforehand.
	    
	    if ( $dim_count )
	    {
		my $base_stmt = "$var_expr = { order => [$order_expr], dim => {} };";
		$self->annotate($phase, 0, $n);
		$self->add_lines($phase, $indent, $base_stmt);
		$self->add_lines($phase, $indent, @loop_lines);
		$self->annotate($phase, 0, $n);
		$self->add_lines($phase, $indent + $dim_count, $init_expr . ';');
		$self->add_lines($phase, $indent, @end_lines, @final_lines);
	    }
	    
	    # Otherwise, we just add the initialization statement.
	    
	    else
	    {
		$self->annotate($phase, 0, $n);
		$self->add_lines($phase, $indent, $init_expr . ';');
	    }
	    
	    # If this is a variable that has a value, then we'll track it.
	    
	    if ( $var_type->_has_value($context) )
	    {
		my ($var_units) = print_units($n->{units});
		my ($value_perl) = $var_type->_value_code($context, $n, 
							  $var_subtype,
							  $var_expr, 'value');
		
		my ($trace_perl) = "\$${rpk}_VAR{'$var_name'} = \$${rpk}_VAR{'$var_expr'} = { name => '$var_name', type => '$var_fulltype', vexpr => '$value_perl', decl_file => '$n->{filename}', decl_line => '$n->{line}', kind => '$kind', units => '$var_units' }";
		
		$self->add_lines('DBGI', 1, $trace_perl . ';');
	    }
	}
    }
    
    # Nodes representing conditionals and conditional loops can be handled
    # together.
    
    elsif ( $nt eq 'IF' || $nt eq 'UNLESS' || $nt eq 'ELSIF' || 
	    $nt eq 'WHILE' || $nt eq 'UNTIL' )
    {
	# Start by generating the conditional, plus the opening brace.
	
	my $word = lc $nt;
	my ($expr, $dim, $type, $units)
	    = $self->generate_expr_perl($child->[0], $context, 'root');
	$self->check_dims_perl($node, $context, $dim, $indent);
	$self->annotate($phase, 0, $node);
	$self->add_lines($phase, $indent, "$word ( $expr ) {");
	my $nc = $context->new($self);
	
	# Generate the code for the body, each statement indented by four
	# spaces more than the enclosing block.
	
	foreach my $n ( @{$node->{children}[1]{children}} ) {
	    $self->generate_perl($n, $phase, $indent+1, $nc);
	}
	
	# Generate the closing brace, and then the 'else' or 'elsif'
	# statement if any.
	
	$self->close_dims_perl($nc, $indent+1);
	$self->add_lines($phase, $indent, "}");
	$self->generate_perl($child->[2], $phase, $indent, $context);
    }
    
    # Nodes representing an ELSE don't have a conditional, of course, so we
    # just need to go through the statements in the body.
    
    elsif ( $nt eq 'ELSE' )
    {
	$self->add_lines($phase, $indent, "else {");
	my $nc = $context->new($self);
	
	foreach my $n ( @{$node->{children}[0]{children}} ) {
	    $self->generate_perl($n, $phase, $indent+1, $nc);
	}
	
	$self->close_dims_perl($nc, $indent+1);
	$self->add_lines($phase, $indent, "}");
    }
    
    # Nodes representing a FOREACH have an index variable followed by a
    # parenthesized list.
    
    elsif ( $nt eq 'FOREACH' )
    {
	my $index_node = $node->{children}[0];
	my $list_node = $node->{children}[1];
	my $body_node = $node->{children}[2];
	
	my ($index_expr, $index_type, $index_dim, $index_units) =
	    $self->generate_expr_perl($index_node, $context, 'root');
	my ($list_expr, $list_type, $list_dim, $list_units) =
	    $self->generate_expr_perl($list_node, $context, 'root');
	
	$indent = $self->check_dims_perl($node, $context, $list_dim, $indent);
	$self->annotate($phase, 0, $node);
	$self->add_lines($phase, $indent, "foreach my \$MADTMP0 ($list_expr) {");
	$self->add_lines($phase, $indent+1, "$index_expr = \$MADTMP0;");
	my $nc = $context->new($self);
	
	# Generate the code for the body, each statement indented by four
	# spaces more than the enclosing block.  Then generate the closing brace.
	
	foreach my $n ( @{$body_node->{children}} ) {
	    $self->generate_perl($n, $phase, $indent+1, $nc);
	}
	
	$self->close_dims_perl($nc, $indent+1);
	$self->add_lines($phase, $indent, "}");
    }
    
    # ACROSS nodes represent implicit loops over one or more dimensions.
    
    elsif ( $nt eq 'ACROSS' )
    {
	my $dimlist_node = $node->{children}[0];
	my $dimlist = $dimlist_node->{children};
	my $dim_count = 0;
	my (@loop_lines, @end_lines, @final_lines);
	
	# Open a new context for the contents of the ACROSS block
	
	my $nc = $context->new($self);
	
	# Open each loop
	
	foreach my $dim_node (@$dimlist)
	{
	    my $dim_rec;
	    
	    if ( ref $dim_node eq 'SETV' )
	    {
		$dim_rec = $self->lookup_dimension($dim_node->{attr});
	    }
	    
	    else
	    {
		$self->syntax_error($node, "dimension in an 'across' must be a set");
		return;
	    }
	    
	    my $rpkg = $self->{runpkg};
	    my $di = '    ' x $dim_count;
	    my $idx = '$' . $rpkg . '_DIM_' . $dim_rec->{name};
	    my $set = '@{$' . $rpkg . $dim_rec->{name} . '->{values}}';
	    my $stmt = $di . "foreach $idx ( $set )";
	    
	    push @loop_lines, $stmt, ($di . '{');
	    push @end_lines, ($di . '}');
	    push @final_lines, "$idx = undef;";
	    $dim_count++;
	    
	    # add the dimension to the context's dimension list
	    
	    push @{$nc->{dimlist}}, $dim_rec;
	}
	
	# Now emit all of the starting lines.
	
	$self->annotate($phase, 0, $node);
	$self->add_lines($phase, $indent, @loop_lines);
	
	# Then add each of the contained lines
	
	foreach my $n ( @{$node->{children}} )
	{
	    next if $n == $dimlist_node;
	    $self->generate_perl($n, $phase, $indent + $dim_count, $nc);
	}
	
	$self->close_dims_perl($nc, $indent + $dim_count);

	# Then close all of the open loops and undefine all index variables.
	
	$self->add_lines($phase, $indent, @end_lines, @final_lines);
    }
    
    # Nodes representing flows are handled by the flow function.
    
    elsif ( $nt eq 'FLOW' or $nt eq 'FLOW_0' or $nt eq 'FLOW_1' ) {
	
	$self->annotate($phase, 0, $node);
	$self->generate_rate_expr_perl($node, $context);
    }
    
    # Any other node type is translated to one or more Perl statements.  If no
    # phase is specified, INIT is assumed by default.
    
    else {
	my ($stmt, $type, $dim, $units) = 
	    $self->generate_expr_perl($node, $context, 'root');
	$self->check_dims_perl($node, $context, $dim, $indent);
	$self->annotate($phase, 0, $node);
	$self->add_lines($phase, $indent+$context->{dim_indent}, $stmt . ';');
    }
}


# generate_function_perl ( $node, $name, $kind, $context, $include_lines )
# 
# Generate Perl code to declare a function.  The name is given by $name, and
# $kind is SELF_METHOD for a method call and FUNCTION otherwise.  The context
# into which the function's name will be entered (and which will be used to
# look up variable names within the function body) is given by $context.  If
# $init_lines is defined, then it points to an array of Perl statements that
# should be included at the beginning of the function.

sub generate_function_perl {
    
    my ($self, $node, $name, $class_name, $context, $include_lines ) = @_;
    
    # We start by deconstructing the node to get three sub-nodes: the type,
    # the parameter list, and the function body.
    
    my $type_node = $node->{children}[0];
    my $plist_node = $node->{children}[1];
    my $body_node = $node->{children}[2];
    
    # We then generate the declaration line.
    
    $self->add_lines('FUNC', 0, "sub $name {");
    
    # If $class_name is given, then this is a method.  Otherwise, it's a
    # function. If it's a method, then we need to include in the chain a new
    # context that points to the class's symbol table.  We also, in this case,
    # need to include a statement to set $this.
    
    my $p_count = 0;
    
    if ( $class_name ) {
	my $class_rec = $self->lookup_static($class_name);
	$context = $context->new($self, $class_rec->{sym});
	$context->{phase} = 'FUNC';
	$self->add_lines('FUNC', 1, 'my ($this) = $_[0];');
	$p_count++;
    }
    
    # In all cases, we next create the context in which parameters and local
    # variables will be declared, and then generate code to receive the
    # parameter values.
    
    my $nc = $context->new($self);
    $nc->{phase} = 'FUNC';
    
    foreach my $nn ( @{$plist_node->{children}} ) {
	my $p_name = $nn->{attr};
	my $type_name = $nn->{children}[0]{attr};
	my $is_ref = $nn->{children}[0]{ref};
	my $units = $nn->{units};
	my ($var_type, $var_subtype, $var_fulltype) =
	    $self->build_type($type_name, ref $nn);
	if ( $is_ref or !$PRIMITIVE_TYPE{$type_name} )
	{
	    $self->add_lines('FUNC', 1, 'my ($' . $p_name . ') = $_[' .
			    $p_count . '];');
	}
	else
	{
	    $self->add_lines('FUNC', 1, 'my ($' . $p_name . 
			    ') = { value => $_[' . $p_count . '] };');
	}
	$p_count++;
	my $var_rec = { name => $p_name, type => $var_fulltype, 
			kind => 'DYN_VAR', decl => $node, units => $units };
	$context->define($p_name, $var_rec);
    }
    
    # This same context also needs to store the return type and units, so that
    # we can check any 'return' statements in the function body for
    # appropriate type and units.
    
    my $return_type = $type_node->{attr};
    my $return_ref = $type_node->{ref};
    if ( $return_ref and $PRIMITIVE_TYPE{$return_type} )
    {
	$return_type = "Scalar<Mad::Gen::$return_type>";
    }
    $context->define('@type', "Mad::Gen::$return_type");
    $context->define('@units', $node->{units});
    
    # If we were given lines of code to include, do so here.  This is used,
    # primarily, to put initialization statements for class variables into the
    # 'init' function.  These have already been generated, because they depend
    # only on the context in which the class was compiled.
    
    if ( ref $include_lines eq 'ARRAY' ) {
	foreach my $line ( @$include_lines ) {
	    $self->add_lines('FUNC', 1, $line);
	}
    }
    
    foreach my $n ( @{$body_node->{children}} ) {
	$self->generate_perl($n, 'FUNC', 1, $nc);
    }
    
    $self->add_lines('FUNC', 0, '}');
    $self->add_lines('FUNC', 0, '');
}


# generate_init_function_perl ( $name, $class_name, $include_lines )
# 
# Generate an initialization function if the user didn't include one.

sub generate_init_function_perl {

    my ($self, $class_name, $include_lines ) = @_;
    
   # We start by generating the declaration line.
    
    $self->add_lines('FUNC', 0, "sub init {");
    
    # The only parameter is $self.
    
    $self->add_lines('FUNC', 1, 'my ($this) = @_;');
    
    # If we were given lines of code to include, do so here.  This is used,
    # primarily, to put initialization statements for class variables into the
    # 'init' function.  These have already been generated, because they depend
    # only on the context in which the class was compiled.
    
    if ( ref $include_lines eq 'ARRAY' ) {
	foreach my $line ( @$include_lines ) {
	    $self->add_lines('FUNC', 1, $line);
	}
    }
    
    $self->add_lines('FUNC', 0, '}');
    $self->add_lines('FUNC', 0, '');
}


# generate_expr_perl ( $node, $context, $parent )
# 
# Generate Perl code from the given node of the parse tree.  This routine
# calls itself recursively as needed to handle sub-nodes.  The $parent
# parameter is either empty, or is the operator associated with the parent
# node of the tree, or is 'root' to indicate the root node of an expression.
# This parameter is used to suppress unnecessary parentheses.
# 
# The function returns a quadruple: (expression, dimension, type, units).

sub generate_expr_perl {

    my ($self, $node, $context, $parent) = @_;
    
    # As a backstop, return the empty string if we are called without a valid
    # node reference.
    
    return '' unless ref $node;
    
    # Set $nt to the node type, which is specified as the type that $node was
    # blessed into.  $attr is the node attribute, and $child is a reference to
    # the array of the node's children.
    
    my $nt = ref $node;
    my $attr = $node->{attr};
    my $child = $node->{children};
        
    # Now handle the various node types.
    
    # BNOP nodes encode Binary Numeric OPerators such as + or -.  The operator
    # in question is specified by the attribute.  These can be directly
    # inserted into the generated Perl code, except for '^' (exponentiation)
    # which needs to be translated to '**'.  We use parentheses even when
    # these are not strictly necessary, to avoid having to worry about
    # differences in operator precedence between Mad and Perl.  But we can
    # skip them if the operator is + or * and the higher operator is the same
    # (so that sequences of a+b+c+... don't get extra parentheses).
    
    if ( $nt eq 'BNOP' ) {
	my $op = $OP_TRANS_PERL{$attr} || $attr;
	my ($expr1, $type1, $dim1, $units1) = 
	    $self->generate_expr_perl($child->[0], $context, $op);
	my ($expr2, $type2, $dim2, $units2) = 
	    $self->generate_expr_perl($child->[1], $context, $op);
	return unless $type1 && $type2;
	my ($expr_code, $expr_type, $expr_dim) = 
	    $self->write_bnop_perl($node, $op, $parent, 
				   $expr1, $type1, $dim1,
				   $expr2, $type2, $dim2);
	my ($expr_units) = $self->merge_units($node, $units1, $units2, $expr2);
	return $expr_code, $expr_type, $expr_dim, $expr_units;
    }
    
    # The Binary Logical OPerators are handled in the same manner as the
    # Numeric ones.  Units, however, only matter if the resulting type is
    # numeric.
    
    elsif ( $nt eq 'BLOP' ) {
	my $op = $OP_TRANS_PERL{$attr} || $attr;
	my ($expr1, $type1, $dim1, $units1) = 
	    $self->generate_expr_perl($child->[0], $context, $op);
	my ($expr2, $type2, $dim2, $units2) = 
	    $self->generate_expr_perl($child->[1], $context, $op);
	return unless $type1 && $type2;
	my ($expr_code, $expr_type, $expr_dim) = 
	    $self->write_blop_perl($node, $op, $parent, 
				   $expr1, $type1, $dim1,
				   $expr2, $type2, $dim2);
	my ($expr_units);
	if ( $expr_type eq 'Mad::Gen::int' or $expr_type eq 'Mad::Gen::num' ) {
	    $expr_units = $self->check_units_compare($node, $units1, $units2);
	}
	return $expr_code, $expr_type, $expr_dim, $expr_units;
    }
    
    # Ditto the Multiple String OPerator (of which there is currently only one
    # variety: concatenation.)  Note that units are irrelevant for strings,
    # and that there is no ambiguity about type and units.  The result of an ~
    # operator is always a string.  Strings have no units.
    
    elsif ( $nt eq 'MSOP' ) {
	my $op = $OP_TRANS_PERL{$attr} || $attr;
	my $expr = '';
	foreach my $n (@$child) {
	    # Note that strings have no units
	    my ($code, $type, $dim) = $self->generate_expr_perl($n, $context, $op);
	    $expr .= " $op " if $expr ne '';
	    $expr .= $code;
	    # $$$$ what do we do with the dimensions ???
	}
	if ( $parent eq '.' or $parent eq 'root' ) {
	    return $expr, 'Mad::Gen::string', undef;
	}
	else {
	    return "($expr)", 'Mad::Gen::string', undef;
	}
    }
    
    # And the RELational OPerators.  Note that the result is always boolean
    # and has no units.
    
    elsif ( $nt eq 'RELOP' ) {
	my $op = $OP_TRANS_PERL{$attr} || $attr;
	my ($expr1, $type1, $dim1, $units1) = 
	    $self->generate_expr_perl($child->[0], $context, $op);
	my ($expr2, $type2, $dim2, $units2) = 
	    $self->generate_expr_perl($child->[1], $context, $op);
	return unless $type1 && $type2;
	# boolean result has no units, but we need to make sure that we are
	# comparing two values with compatible units.
	if ( ref $node->{units} eq 'Units' )
	{
	    $self->syntax_error($node, "you cannot override units on a relational expression");
	}
	$self->check_units_compare($node, $units1, $units2);
	my ($expr_code, $expr_type, $expr_dim) = 
	    $self->write_relop_perl($node, $op, $parent, 
				    $expr1, $type1, $dim1, 
				    $expr2, $type2, $dim2);
	return $expr_code, $expr_type, $expr_dim;
    }
    
    # Unary Minus is also quite straightforward.  The only thing even remotely
    # complicated is that negating a boolean value gives an integer value.
    
    elsif ( $nt eq 'UMINUS' ) {
	my ($code, $type, $dim, $units) = 
	    $self->generate_expr_perl($child->[0], $context, 'uminus');
	if ( $type eq 'Mad::Gen::flag' ) { $type = 'Mad::Gen::int'; }
	return "-$code", $type, $dim, $units;
    }
    
    # So is the unary NOT operator.  Note that units are irrelevant for
    # a boolean result, and the type is always boolean.
    
    elsif ( $nt eq 'NOT' ) {
	my ($code, $type, $dim) = 
	    $self->generate_expr_perl($child->[0], $context, 'not');
	return "not($code)", 'Mad::Gen::flag', $dim;
    }
    
    # Numeric and String literals are handled by just returning their
    # values.
    
    elsif ( $nt eq 'NUM' ) {
	if ( $attr =~ /^(\+|\-)?[0-9]+$/ ) {
	    return $attr, 'Mad::Gen::int', undef, $node->{units};
	}
	else {
	    return $attr, 'Mad::Gen::num', undef, $node->{units};
	}
    }
    
    # Strings have either dimension nor units.
    
    elsif ( $nt eq 'STR' ) {
	return "'$attr'", 'Mad::Gen::string';
    }
    
    elsif ( $nt eq 'ESC' ) {
	return "\"$attr\"", 'Mad::Gen::string';
    }
    
    # Nor do boolean literals
    
    elsif ( $nt eq 'LITERAL' ) {
	if ( $attr eq 'TRUE' ) {
	    return "1", 'Mad::Gen::flag';
	} elsif ( $attr eq 'FALSE' ) {
	    return "0", 'Mad::Gen::flag';
	} elsif ( $attr eq 'NULL' ) {
	    return "undef", 'Mad::Gen::general', undef, $Mad::Model::UNIT_WILDCARD;
	} else {
	    $self->syntax_error($node, "unknown literal '$attr'");
	}
    }
    
    # Lists are handled by evaluating each child.
    
    elsif ( $nt eq 'LIST' ) {
	my $list_expr = '';
	my ($list_type, $list_dim, $list_units);
	foreach my $n (@$child) {
	    my ($elt_expr, $elt_type, $elt_dim, $elt_units) = 
		$self->generate_expr_perl($n, $context, 'list');
	    return unless $elt_type;
	    $list_expr .= ', ' if $list_expr ne '';
	    $list_expr .= $elt_expr;
	    if ( $elt_type =~ /^Mad::Gen::(List|Set)<(.*)>$/ )
	    {
		# Lists are flat
		$elt_type = $2;
	    }
	    unless ( defined $list_type )
	    {
		$list_type = $elt_type;
	    }
	    elsif ( $list_type ne $elt_type )
	    {
		$list_type = 'Mad::Gen::general';
	    }
	    $list_units = merge_list_units($list_units, $elt_units);
	}
	return "(${list_expr})", "Mad::Gen::List<$list_type>", undef, $list_units;
    }
    
    # Ranges are similar
    
    elsif ( $nt eq 'DOTDOT' ) {
	my ($expr1, $type1, $dim1, $units1) = 
	    $self->generate_expr_perl($child->[0], $context, '..');
	my ($expr2, $type2, $dim2, $units2) = 
	    $self->generate_expr_perl($child->[1], $context, '..');
	return unless $type1 && $type2;
	my ($range_expr) = $expr1 . '..' . $expr2;
	my ($range_type, $range_dim);
	unless ( $PRIMITIVE_TYPE{$type1} and $PRIMITIVE_TYPE{$type2} )
	{
	    $self->syntax_error($node, "range operator requires a simple type");
	}
	if ( $type1 eq $type2 )
	{
	    $range_type = $type1;
	}
	else
	{
	    $range_type = 'Mad::Gen::general';
	}
	my ($range_units) = $self->merge_units($node, $units1, $units2, $expr2);
	return $range_expr, $range_type, $range_dim, $range_units;
    }
    
    # Nodes that represent an expression which evaluates to the value of some
    # variable are handled by generate_var_expr_perl().  If this expression is
    # being evaluated as the argument to a binding-expression ($parent is
    # 'bind') then we pass '&' to the subroutine.  This indicates that the
    # address of the variable should be returned rather than its value.
    
    elsif ( $nt eq 'SCALARV' or $nt eq 'LISTV' or $nt eq 'SETV' ) {
	my ($selector) = $parent eq 'bind' ? '&' : '';
	my ($var_expr, $var_type, $var_dim, $var_units) =
	    $self->generate_var_expr_perl($node, $context, $selector);
	return $var_expr, $var_type, $var_dim, $var_units;
    }
    
    elsif ( $nt eq 'INDEXV' ) {
	my ($var_expr, $var_type, $var_dim, $var_units) =
	    $self->generate_index_expr_perl($node, $context);
	return $var_expr, $var_type, $var_dim, $var_units;
    }
    
    # Nodes representing assignment of a new value to a variable are also
    # handled by generate_var_expr_perl().
    
    elsif ( $nt eq 'ASSIGN' ) {
	if ( $parent eq 'bind' && $attr ne ':=' )
	{
	    $self->syntax_error($node, "inappropriate context for assignment");
	    return '**ERROR**';
	}
	my ($var_expr, $var_type, $var_dim, $var_units) =
	    $self->generate_var_expr_perl($child->[0], $context, $attr, 
					  $child->[1]);
	return $var_expr, $var_type, $var_dim, $var_units;
    }
    
    # Nodes representing the use of a pseudo-variable are handled in a similar
    # manner.
    
    elsif ( $nt eq 'PVAR' ) {
	#my $basevar = $self->var_name_perl($node, 'PVAR');
	#my $class = "Mad::Gen::PseudoVar";
	#$self->check_var($node);
	#my $frag = $class->_value_code('perl', $context, $node, 
	#			     $basevar, 'value');
	return "**PVAR**", undef, 'num';
    }
    
    # Postfix or prefix increment operators are appended or prepended as
    # specified.
    
    elsif ( $nt eq 'POSTOP' or $nt eq 'PREFOP' ) {
	my $op = $attr;
	unless ( ref $child->[0] eq 'SCALARV' ) {
	    $self->syntax_error($node, "you cannot apply $op to anything except a scalar variable");
	}
	my ($code, $type, $dim, $units) = 
	    $self->generate_expr_perl($child->[0], $context, $op);
	if ( $nt eq 'POSTOP' ) {
	    return $code . $op, $type, $dim, $units;
	} else {
	    return $op . $code, $type, $dim, $units;
	}
    }
    
    # Nodes representing control statements are translated to Perl
    
    elsif ( $nt eq 'CTRL' ) {
	my ($arg, $type, $dim, $units) 
	    = $self->generate_expr_perl($child->[0], $context, 'root');
	if ( $attr eq 'return' ) {
	    my $return_type = $context->lookup('@type');
	    my $return_units = $context->lookup('@units');
	    if ( $arg ne '' and ($return_type eq 'void' or 
				 $return_type eq 'Mad::Gen::void' ) )
	    {
		$self->syntax_error($node, "cannot return a result from a void function");
	    }
	    elsif ( $return_type eq '' )
	    {
		$self->syntax_error($node, "cannot return from outside of a function");
	    }
	    else
	    {
		my $op = $PRIMITIVE_TYPE{$return_type} ? '=' : ':=';
		$self->check_types_assign($node, $return_type, $type, $op, 'return');
		$arg = $self->tr_type_perl($arg, $type, $return_type);
	    }
	    $self->check_units_assign($node, $return_units, $units, 'return');
	    return "return $arg", $return_type, $dim, $return_units;
	}
	elsif ( $attr eq 'die' ) {
	    return "die $arg", 'void', $dim;
	}
	else {
	    $self->syntax_error($node, "unknown control operator: $attr");
	    return '**ERROR**';
	}
    }
    
    elsif ( $nt eq 'PRINT' ) {
	# print can take more than one parameter, so we go through all of
	# them.  Perl can print all scalars and expressions of primitive type
	# without any fuss, but any other type must be stringified.
	my $argstring = '';
	my (@dims, $final_dim);
	foreach my $n ( @$child )
	{
	    my ($arg, $type, $dim, $units) =
		$self->generate_expr_perl($n, $context, 'root');
	    $arg = tr_type_perl($arg, $type, 'Mad::Gen::string') unless
		$PRIMITIVE_TYPE{$type} or $type =~ /^Mad::Gen::Scalar/;
	    $argstring .= ', ' if $argstring ne '';
	    $argstring .= $arg;
	    push @dims, $dim;
	}
	# merge the dimensions
	$final_dim = merge_dimlist(@dims);
	# now generate the proper statement
	if ( $attr eq 'print' )
	{
	    return "print $argstring";
	}
	
	elsif ( $attr eq 'println' )
	{
	    return "print $argstring, \"\\n\"";
	}
    }
    elsif ( $nt eq 'FUNCALL' ) {
	my $fun_rec;
	unless ( $fun_rec = $self->lookup_static($attr) ) {
	    $self->syntax_error($node, "unknown function '$attr'");
	    return '**ERROR**';
	}
	my $fun_type = $fun_rec->{type};
	my $fun_units = $fun_rec->{units};
	my @fun_sig = @{$fun_rec->{sig}};
	my $arg_string = '';
	my $pnum = 1;
	foreach my $n ( @{$node->{children}} ) {
	    unless ( @fun_sig ) {
		$self->syntax_error($node, "too many parameters for function '$attr'");
		return '**ERROR**';
	    }
	    my $p_type = shift @fun_sig;
	    my $p_units = shift @fun_sig;
	    my $selector = $PRIMITIVE_TYPE{$p_type} ? 'root' : 'bind';
	    my ($arg, $type, $dim, $units) = $context->evaluate($n, $selector);
	    return '**ERROR**' unless $type;
	    $self->check_units_assign($node, $p_units, $units, '=', $pnum);
	    if ( $selector eq 'bind' and $p_type ne $type )
	    {
		$self->syntax_error($node, "parameter $pnum is $type, should be $p_type");
	    }
	    $arg_string .= ', ' if $arg_string;
	    $arg_string .= $arg;
	    $pnum++;
	}
	return "$attr($arg_string)", $fun_type, undef, $fun_units;
    }
    
    # Otherwise, we signal an error so the programmer knows that there are
    # other node types not yet handled :)
    
    else {
	$self->syntax_error($node, "UNHANDLED NODE TYPE: $nt");
    }
}


# generate_var_expr_perl ( $node, $context, $op, $value_node )
# 
# Generate a perl expression for the variable indicated by $node.  $context is
# used to lookup any necessary variable names.  $op indicates which operation
# is being requested.  If empty, we return an expression that evaluates to the
# value of the variable.  If '&', we return an expression that evaluates to
# the address of hte variable.  If '=', '+=', '*=', etc., we return an
# expression that assigns a new value to the variable.  In this case, the
# value-expression is given by $value_node.  If ':=', we return an expression
# that rebinds the variable's name to a different variable (the equivalent of
# asigning a different address to a pointer variable in C).
# 
# The node $node is checked to see if it has children that modify the variable
# by subscripts, subfields, method calls, etc.  If so, these are applied in
# order to generate a complex variable expression such as "$a.b[$i].c".
# 
# Returns the usual list of: (expression, type, dimension, units)

sub generate_var_expr_perl {
    
    my ($self, $node, $context, $op, $value_node) = @_;
    
    my $nt = ref $node;
    my $var_rec;
    
    # First make sure we have an lvalue (a value that could be assigned to).
    # This could only happen with an assignment statement, since the only
    # other way to get to this routine is with the node type being one of
    # those listed below.
    
    unless ( $nt eq 'SCALARV' or $nt eq 'LISTV' or $nt eq 'SETV' or
	     $nt eq 'PVAR' )
    {
	$self->syntax_error($node, "'$node->{attr}' is not an lvalue");
	return '**ERROR**';
    }
    
    # Then make sure we are referring to a variable that we know about.
    
    unless ( $var_rec = $context->lookup($node->{attr}) )
    {
	$self->syntax_error($node, "unknown variable '$node->{attr}'");
	return '**ERROR**';
    }
    
    # The first thing to do is to determine the variable's name, type,
    # kind, etc.
    
    my $var_kind = $var_rec->{kind};
    my $var_type = $var_rec->{type};
    my $var_units = $var_rec->{units};
    my @var_dim = @{$var_rec->{dim}} if ref $var_rec->{dim} eq 'ARRAY';
    my $rpkg = $self->{runpkg};
    
    return '**ERROR**' unless $var_type;
    
    my ($var_expr, $var_class, $var_subtype, $sub_dim, $sub_units);
    
    # Now we figure out the name.  If it's a dynamic variable, its name is
    # simple
    
    if ( $var_kind eq 'DYN_VAR' ) {
	$var_expr = '$' . $node->{attr};
    }
    
    # If it's an attribute of a class whose definition is currently being
    # processed (i.e. this routine was called from within the definition
    # of a method inside the class) then the variable is actually a member
    # of the hash pointed to by '$this'.
    
    elsif ( $var_kind eq 'ATTR' ) {
	$var_expr = '$this->{' . $node->{attr} . '}';
    }
    
    # Otherwise, it's a package variable.
    
    else {
	$var_expr = '$' . $self->{runpkg} . $node->{attr};
    }
    
    # Deconstruct the variable's type and make sure we're using it
    # properly.
    
    if ( $var_type =~ /^Mad::Gen::Set<(.*)>/ )
    {
	$var_class = 'Mad::Gen::Set';
	$var_subtype = $1;
	unless ( $nt eq 'SETV' )
	{
	    $self->syntax_error($node, "variable '$node->{attr}' was declared as a set");
	    return '**ERROR**';
	}
    }
    
    elsif ( $var_type =~ /^Mad::Gen::List<(.*)>/ )
    {
	$var_class = 'Mad::Gen::List';
	$var_subtype = $1;
	unless ( $nt eq 'LISTV' )
	{
	    $self->syntax_error($node, "variable '$node->{attr}' was declared as a list");
	    return '**ERROR**';
	}
    }
    
    elsif ( $var_type =~ /^Mad::Gen::Scalar<(.*)>/ )
    {
	$var_class = 'Mad::Gen::Scalar';
	$var_subtype = $1;
	unless ( $nt eq 'SCALARV' )
	{
	    $self->syntax_error($node, "variable '$node->{attr}' was declared as a scalar");
	    return '**ERROR**';
	}
    }    
    
    elsif ( $var_type =~ /^(.*)<(.*)>$/ )
    {
	$var_class = $1;
	$var_subtype = $2;
    }
    
    else
    {
	$var_class = $var_type;
    }
    
    # Now add the part of the code that handles dimensionality.
    
    if ( @var_dim ) {
	$var_expr .= '->{dim}';
    }
    
    my $dim_expr = '';
    my @unresolved_dim;
    
    # Go through the child nodes, handling each in turn.  The last node is
    # handled differently if it is a subfield node: if the operation is an
    # assignment (i.e. something different from := or &), then we remember the
    # last subfield name and use it later when calling _set_code.
    
    my $last_n = $node->{children}[-1];
    my $asgn_op = ($op eq ':=' || $op eq '&') ? '' : $op;
    my $asgn_attr;
    
    foreach my $n ( @{$node->{children}} )
    {
	my $nt = ref $n;
	
	# If the child specifies a subscript, then we evaluate the
	# corresponding dimension in the variable.
	
	if ( $nt eq 'SUBSCRIPT' )
	{
	    my ($sub_expr, $sub_dim, $sub_type) = 
		$self->generate_expr_perl($n->{children}[0], $context, 'root');
	    
	    unless (@var_dim)
	    {
		$self->syntax_error($node, "too many subscripts on '$node->{attr}'");
	    }
	    
	    my $this_dim = pop @var_dim;
	    
	    unless ( $sub_type eq $this_dim->{type} )
	    {
		$self->syntax_error($node, "subscript on $node->{attr}' is of type $sub_type but should be $this_dim->{type}");
		return '**ERROR**';
	    }
	    
	    unless ( $sub_dim eq undef )
	    {
		$self->syntax_error($node, "for now, subscript expressions cannot themselves have dimension");
		return '**ERROR**';
	    }
	    
	    # $$$$ need to make sure we don't leave any unresolved dimensions
	    # in the subscript expression that are the same as the dimension
	    # being computed.
	    
	    $dim_expr = "{$sub_expr}" . $dim_expr;
	}
	
	# If the child specifies an empty subscript, we record this as an
	# unresolved dimension.
	
	elsif ( $nt eq 'SUBSEMPTY' )
	{
	    my $this_dim = pop @var_dim;
	    my $dim_varname = '$' . $rpkg . '_DIM_' . $this_dim->{name};
	    unshift @unresolved_dim, $this_dim;
	    
	    $dim_expr = "{$dim_varname}" . $dim_expr;
	}
	
	# If the child specifies a subfield, and this is not the last node,
	# then we call _value_code (for the appropriate type) to get the
	# proper expression.  If this is the last node, and we are processing
	# an assignment operation, we remember the attribute instead so that
	# we can call _set_code later.
	
	elsif ( $nt eq 'SUBFIELD' )
	{
	    if ( $n == $last_n and $asgn_op ne '' )
	    {
		$asgn_attr = $n->{attr};
	    }
	    
	    else
	    {
		return '**ERROR**' unless $var_class ne '' && 
		    $var_class->can("_value_code");
		
		($var_expr, $var_type, $sub_dim, $sub_units) = 
		    $var_class->_value_code($context, $n, $var_subtype,
					   $var_expr, $n->{attr});
	    }
	}
	
	# If the child specifies a method call, we call _metcall_code (for the
	# appropriate type) to get the proper expression.
	
	elsif ( $nt eq 'METCALL' )
	{
	    return '**ERROR**' unless $var_type ne '' && 
		$var_type->can("_metcall_code");
	    
	    ($var_expr, $var_type, $sub_dim, $sub_units) = 
		$var_class->_metcall_code($context, $n, $var_subtype,
					  $var_expr, $n->{attr},
					  @{$n->{children}});
	}
	
	# If we get anything else, it's an error.
	
	else
	{
	    $self->syntax_error($node, 'Internal error: variable child node');
	}
	
	# If an error occurred, abort.
	
	return '**ERROR**' unless $var_type;
	
	# Finally, deconstruct the new type, which might depend upon the
	# secondary type (i.e. a particular element from a list or set).
	
	if ( $var_type eq '@' )
	{
	    $var_type = $var_subtype;
	    $var_subtype = undef;
	    $var_class = $var_type;
	}
	
	elsif ( $var_type =~ /^(.*)<(.*)>/ )
	{
	    $var_class = $1;
	    $var_subtype = $2 unless $2 eq '@';
	}
	
	else
	{
	    $var_class = $var_type;
	    $var_subtype = undef;
	}
    }
    
    # We now collect up all of the unresolved dimensions and add the dimension
    # expression (if any) to $var_expr.  Each unresolved dimension gets an
    # iterator that corresponds to its name, and the list of unresolved
    # dimensions is also returned with the result of this function.
    
    while (@var_dim)
    {
	my $this_dim = pop @var_dim;
	my $dim_varname = '$' . $rpkg . '_DIM_' . $this_dim->{name};
	unshift @unresolved_dim, $this_dim;
	
	$dim_expr = "{$dim_varname}" . $dim_expr;
    }
    
    my $var_dim = \@unresolved_dim if scalar(@unresolved_dim) > 0;
    
    $var_expr .= $dim_expr;
    
    # Then we finish generating the expression
    
    # If this is an assignment or binding, we need to call _set_code to generate
    # the correct expression.
    
    if ( $op eq ':=' )
    {
	if ( $PRIMITIVE_TYPE{$var_type} )
	{
	    $self->syntax_error($node, "'$node->{attr}' cannot be assigned to");
	    return '**ERROR**';
	}
	
	my ($asgn_dim, $asgn_type, $asgn_units);
	
	# $$$$ need to handle sets and lists
	
	($var_expr, $asgn_type, $asgn_dim, $asgn_units) = 
	    $var_class->_set_code($context, $node, $var_subtype, $var_expr,
				  $asgn_attr, ':=', $value_node);
	
	# $$$$ need to make sure that dimensions are compatible!!!
	
	$self->check_units_assign($node, $var_units, $asgn_units, 
				  $asgn_attr || $node->{attr});
	
	return $var_expr, $var_type, $var_dim, $var_units;
    }
    
    # If this is a regular assignment, we also call _set_code.
    
    elsif ( $asgn_op ne '' )
    {
	if ( $PRIMITIVE_TYPE{$var_type} )
	{
	    $self->syntax_error($node, "'$node->{attr}' cannot be assigned to");
	    return '**ERROR**';
	}
	
	my ($asgn_dim, $asgn_type, $asgn_units);
	
	# $$$$ need to handle sets and lists
	
	($var_expr, $asgn_type, $asgn_dim, $asgn_units) =
	    $var_class->_set_code($context, $node, $var_subtype, $var_expr,
				  $asgn_attr , $asgn_op, $value_node);
	
	# $$$$ need to make sure that dimensions are compatible!!!
	
	$self->check_units_assign($node, $var_units, $asgn_units,
				  $asgn_attr || $node->{attr});
	
	return $var_expr, $var_type, $var_dim, $var_units;
    }
    
    # If $op is '&', we need to generate an expression that will produce a
    # reference to the variable.
    
    elsif ( $op eq '&' )
    {
	$var_units = $self->check_node_units($node, $sub_units || $var_units);
	
	return $var_expr, $var_type, $var_dim, $var_units;
    }
    
    # Otherwise, we need to generate an expression that will produce the
    # variable's current value.
    
    else
    {
	# If the type is already primitive, we just need to check units.
	
	if ( $PRIMITIVE_TYPE{$var_type} )
	{
	    $var_units = $self->check_node_units($node, $sub_units || $var_units);
	    
	    return $var_expr, $var_type, $var_dim, $var_units;
	}
	
	# If it is void, we don't even have to do that.
	
	elsif ( $var_type eq 'Mad::Gen::void' or $var_type eq 'void' )
	{
	    return $var_expr, 'Mad::Gen::void';
	}
	
	# Otherwise, we need to call _value_code to generate a proper value
	# expression. 
	
	else
	{
	    ($var_expr, $var_type) = 
		$var_class->_value_code($context, $node, $var_subtype, $var_expr, 
					'value');
	    
	    $var_units = $self->check_node_units($node, $sub_units || $var_units);
	    
	    return $var_expr, $var_type, $var_dim, $var_units;
	}
    }
}


# generate_index_expr_perl ( $node, $context )
# 
# Generate Perl code for the index expression represented by $node.

sub generate_index_expr_perl {

    my ($self, $node, $context) = @_;
    
    my $name = $node->{attr};
    my $rpkg = $self->{runpkg};
    
    if ( $name =~ /^[a-zA-Z]/ )
    {
	if ( my $dim_rec = $self->lookup_dimension($name) )
	{
	    return "\$${rpkg}_DIM_${name}", $dim_rec->{type};
	}
	
	else
	{
	    $self->syntax_error($node, "unknown dimension: $name");
	}
    }
    
    elsif ( $name =~ /^\d+$/ )
    {
	my @dims = reverse @{$context->{dimlist}};
	push @dims, reverse @{$context->{dimlist_inherited}};
	
	if ( $name > @dims )
	{
	    $self->syntax_error($node, "there are only " . scalar(@dims) . " dimensions here");
	    return;
	}
	
	my $dim_rec = $dims[$name-1];
	return "\$${rpkg}_DIM_$dim_rec->{name}", 'Mad::Gen::int';
    }
}


# generate_init_expr_perl ( $node )
# 
# Generate an initialization expression for the variable represented by $node.

sub generate_init_expr_perl {

    my ($self, $node) = @_;
    
    my $runpkg = $self->{runpkg};
    my $name = $node->{attr};
    
    return '$' . $runpkg . '_INIT{' . $name . '}';
}


# tr_type_perl ( $expr, $from_type, $to_type )
# 
# Modify $expr to transform a value of type $from_type to type $to_type.  If
# no transformation is needed, return $expr unchanged.

sub tr_type_perl {

    my ($self, $expr, $from_type, $to_type) = @_;
    
    # If either type is empty, or the expression is empty, abort
    
    unless ( defined $from_type and defined $to_type and defined $expr )
    {
	return;
    }
    
    # If the two types are identical, or the expression is the typeless
    # 'undef', we don't need to do anything
    
    if ( $to_type eq $from_type || $expr eq 'undef' )
    {
	return $expr;
    }
    
    # If $from_type is primitive, we can use some easy conversion
    # expressions.
    
    elsif ( $PRIMITIVE_TYPE{$from_type} or $from_type =~ /^Mad::Gen::Scalar/ )
    {
	if ( $to_type =~ /Mad::Gen::num\b/ and $from_type !~ /Mad::Gen::int\b/ )
	{
	    return "(0.0+$expr)";
	}
	
	elsif ( $to_type =~ /Mad::Gen::int\b/ )
	{
	    return "int($expr)";
	}
	
	elsif ( $to_type =~ /Mad::Gen::flag\b/ )
	{
	    return "($expr ? 1 : 0)";
	}
	
	else
	{
	    return $expr;
	}
    }
    
    # If $from_type is a list and $to_type is not, we need to extract the
    # first element.  If they are both lists, the source list needs to be converted.
    
    elsif ( $from_type =~ /^Mad::Gen::list<(.*)>/ )
    {
	my $from_subtype = $1;
	
	if ( $to_type eq $from_subtype or $to_type eq 'Mad::Gen::general' )
	{
	    return "$expr->[0]";
	}
	
	elsif ( $to_type eq 'Mad::Gen::num' )
	{
	    return "(0.0+$expr->[0])";
	}
	
	elsif ( $to_type eq 'Mad::Gen::int' )
	{
	    return "int($expr->[0])";
	}
	
	elsif ( $to_type eq 'Mad::Gen::flag' )
	{
	    return "($expr->[0] ? 1 : 0)";
	}
	
	elsif ( $to_type =~ /^Mad::Gen::(list|set)/ )
	{
	    # $$$$ we need to come up with syntax for pass-by-reference and
	    # read-only parameters!  Otherwise, we'll be copying list elements
	    # all day.  If a parameter is pass-by-reference, then it
	    # definitely needs to be the same type as the argument.  But we
	    # may be able to define 'read-only' parameters that don't require
	    # this.  Perhaps we can pass a proxy that has a reference to the
	    # original but is also marked as "convert-to-int" or some such?
	    return $expr;
	}
    }
    
    # If this is a case we haven't caught, then we have to assume that
    # $from_type is a subclass of $to_type.
    
    else
    {
	return $expr;
    }
}


# dimension_perl ( $var_dim, $var_expr, $init_expr, $value_expr )
# 
# Generate an appropriate dimensioned initialization statement using teh given
# arguments.  This routine will only be called if $var_dim is a reference to a
# non-empty array.

sub dimension_perl {

    my ($self, $var_dim, $var_expr, $init_expr, $value_expr) = @_;
    
    my $dim_count = 0;
    my $dim_expr = '';
    
    # First add the statement that initializes the base of the dimension hash
    # structure.
    
    my @stmts = "$var_expr = { dim => {} };";
    
    # Then add loops for each dimension.
    
    foreach my $dim_rec ( @$var_dim )
    {
	my $rpkg = $self->{runpkg};
	my $idx = '$' . $rpkg . '_DIM_' . $dim_rec->{name};
	my $set = '@{$' . $rpkg . $dim_rec->{name} . '->{values}}';
	my $stmt = "foreach $idx ( $set )";
	my $indent = '    ' x $dim_count;
	push @stmts, $indent . $stmt, $indent . '{';
	$dim_expr .= "{$idx}";
	$dim_count++;
    }
    
    # Now add the core initialization statement.
    
    my $indent = '    ' x $dim_count;
    my $stmt = $indent . $var_expr . '->{dim}' . $dim_expr . 
	" = { value => $init_expr || $value_expr };";
    
    # Then close the loops.
    
    while ( $dim_count > 0 )
    {
	$dim_count--;
	$indent = '    ' x $dim_count;
	push @stmts, $indent . '}';
    }
    
    return @stmts;
}


# write_bnop_perl ( $node, $op, $parent, $expr1, $type1, $expr2, $type2 )
# 
# Generate Perl code for a Binary Numeric OPerator expression.

sub write_bnop_perl {
    
    my ($self, $node, $op, $parent, 
	$expr1, $type1, $dim1, 
	$expr2, $type2, $dim2) = @_;
    
    my ($ncode, $ntype, $ndim);
    
    # A check for operator overloading will eventually go here.
    
    unless ( $PRIMITIVE_TYPE{$type1} && $PRIMITIVE_TYPE{$type2} ) {
	$self->syntax_error($node, "Operator overloading not implemented yet.");
	return '**ERROR**';
    }
    
    # Otherwise, we use the basic scheme.
    
    else {
	
	# Max and min are implemented as function calls.
	
	if ( $op eq 'min' )
	{
	    $ncode = "Mad::Math::max($expr1, $expr2)";
	}
	
	elsif ( $op eq 'max' )
	{
	    $ncode = "Mad::Math::min($expr1, $expr2)";
	}
	
	# The rest are implemented using the regular Perl operators.  Adjacent
	# * and + do not need extra parentheses.
	
	elsif ( $op eq '+' and $parent eq '+' or
	     $op eq '*' and $parent eq '*' or
	     $parent eq 'root' )
	{
	    $ncode = "$expr1 $op $expr2";
	}
	
	# Everything else uses explicit parentheses.
	
	else
	{
	    $ncode = "($expr1 $op $expr2)";
	}
	
	# The type is generally determined by the highest type among:
	#   general -> num -> int
	# with flag being promoted to int and string being promoted to
	# general.
	
	if ( $type1 eq 'Mad::Gen::general' or $type2 eq 'Mad::Gen::general' or
	     $type1 eq 'Mad::Gen::string' or $type2 eq 'Mad::Gen::string' ) {
	    $ntype = 'Mad::Gen::general';
	}
	elsif ( $type1 eq 'Mad::Gen::num' or $type2 eq 'Mad::Gen::num' ) {
	    $ntype = 'Mad::Gen::num';
	}
	else {
	    $ntype = 'Mad::Gen::int';
	}
    }
    
    # Now compute the union of the two sets of dimensions.
    
    $ndim = merge_dimlist($dim1, $dim2);
    
    # Return them.
    
    return $ncode, $ntype, $ndim;
}


# write_blop_perl ( $node, $op, $parent, $expr1, $type1, $expr2, $type2 )
# 
# Generate Perl code for a Binary Logical OPerator expression.

sub write_blop_perl {
    
    my ($self, $node, $op, $parent, 
	$expr1, $type1, $dim1,
	$expr2, $type2, $dim2) = @_;
    
    my ($ncode, $ntype, $ndim);
    
    # A check for operator overloading will eventually go here.
    
    unless ( $PRIMITIVE_TYPE{$type1} && $PRIMITIVE_TYPE{$type2} ) {
	$self->syntax_error($node, "Operator overloading not implemented yet.");
	return '**ERROR**';
    }
    
    # Otherwise, we use the basic scheme.
    
    else {
	
	# The code is surrounded by parentheses except in a few cases.
	
	if ( $op eq '&&' and $parent eq '&&' or
	     $op eq '||' and $parent eq '||' or
	     $parent eq 'root' ) {
	    $ncode = "$expr1 $op $expr2";
	}
	
	else {
	    $ncode = "($expr1 $op $expr2)";
	}
	
	# The type is a bit tricky because we are using the Perl semantics of
	# short-circuiting.  If the two types are the same, that determines
	# the final type.  Otherwise, the final type is 'general'.
	
	if ( $type1 eq $type2 ) {
	    $ntype = $type1;
	}
	else {
	    $ntype = 'Mad::Gen::general';
	}
    }
    
    # Merge dimension lists
    
    $ndim = merge_dimlist($dim1, $dim2);
    
    # Return them.
    
    return $ncode, $ntype;
}


# write_msop_perl ( $node, $op, $parent, $expr1, $type1, $expr2, $type2 )
# 
# Generate Perl code for a Multiple String OPerator expression.

sub write_msop_perl {
    
    my ($self, $node, $op, $parent, 
	$expr1, $type1, $dim1, 
	$expr2, $type2, $dim2) = @_;
    
    my ($ncode, $ntype, $ndim);
    
    # A check for operator overloading will eventually go here.
    
    unless ( $PRIMITIVE_TYPE{$type1} && $PRIMITIVE_TYPE{$type2} ) {
	$self->syntax_error($node, "Operator overloading not implemented yet.");
	return '**ERROR**';
    }
    
    # Otherwise, we use the basic scheme.
    
    else {
	
	# The code is surrounded by parentheses except in a few cases.
	
	if ( $op eq '.' and $parent eq '.' or
	     $parent eq 'root' ) {
	    $ncode = "$expr1 $op $expr2";
	}
	
	else {
	    $ncode = "($expr1 $op $expr2)";
	}
	
	# The type is simple, because the result of string concatenation is
	# always a string.
    }
    
    $ndim = merge_dimlist($dim1, $dim2);
    
    return $ncode, 'Mad::Gen::string', $ndim;
}


# write_relop_perl ( $node, $op, $parent, $expr1, $type1, $expr2, $type2 )
# 
# Generate Perl code for a RELational OPerator expression.

sub write_relop_perl {
    
    my ($self, $node, $op, $parent, 
	$expr1, $type1, $dim1,
	$expr2, $type2, $dim2) = @_;
    
    my ($ncode, $ntype, $ndim);
    
    # Merge the dimension lists
    
    $ndim = merge_dimlist($dim1, $dim2);
    
    # A check for operator overloading will eventually go here.
    
    unless ( $PRIMITIVE_TYPE{$type1} && $PRIMITIVE_TYPE{$type2} ) {
	$self->syntax_error($node, "Operator overloading not implemented yet.");
	return '**ERROR**';
    }
    
    # Otherwise, we use the basic scheme, which is very simple.  The code is
    # always surrounded by parentheses, and the type is always boolean.
    
    else {
	return "($expr1 $op $expr2)", 'Mad::Gen::flag', $ndim;
    }
}


# check_dims_perl ( $self, $context, $newdim, $indent )
# 
# Add or change the dimensionality prior to emitting a new Perl statement.  If
# $IMPLICIT_INDEX is true, then we close any loops corresponding to dimensions
# that are not appropriate to the new statement, and start new loop(s)
# corresponding to any new dimensions.  Otherwise, we check to make sure that
# dimensionality is satisified, and put in a runtime check if necessary.

sub check_dims_perl {

    my ($self, $node, $context, $newdim, $indent) = @_;
    
    my $olddim = $context->{dimlist};
    my $prevdim = $context->{dimlist_inherited};
    my $phase = $context->{phase};
    my $rpkg = $self->{runpkg};
    
    if ( $self->{implicit_index} )
    {
	# First check to see if there are any dimensions in $context->{dimlist}
	# that aren't in $newdim.  If so, these need to be closed, along with any
	# subsequent ones.  Of course, we don't need to do anything if
	# $context->{dimlist} is empty.
	
	if ( scalar(@$olddim) > 0 ) {
	    my $first_to_close;
	
	    if ( ref $newdim eq 'ARRAY' ) {
		foreach my $i (0..$#$olddim) {
		    # Scan through $newdim to see if it's there.
		
		    my $found = 0;
		
		    foreach my $n (@{$newdim}) {
			$found = 1, last if $n == $olddim->[$i];
		    }
		
		    unless ( $found )
		    {
			$first_to_close = $i;
			last;
		    }
		}
	    }
	
	    # If $newdim is empty, then we need to close everything in
	    # $context->{dimlist}.
	
	    else {
		$first_to_close = 0;
	    }
	
	    # Now close them all, in reverse order (newest first).
	
	    for (my $i = $#$olddim; $i >= $first_to_close; $i--) {
		my $this_indent = $indent + $context->{dim_indent} - 1;
		$self->add_lines($phase, $this_indent, '}');
		$context->{dim_indent}--;
		pop @$olddim;
	    }
	}
    
	# Now see if there are any new dimensions to open.  Each dimension is only
	# opened if it is not already in $context->{dimlist} or
	# $context->{dimlist_inherited}.
    
	if ( ref $newdim eq 'ARRAY' and scalar (@$newdim) > 0 ) {
	  DIM:
	    foreach my $d ( @$newdim ) {
		# See if this dimension is in @$olddim; if so, skip it.
	    
		foreach my $e ( @$olddim ) {
		    next DIM if $d == $e;
		}
	    
		# See if this dimension is in @$prevdim; if so, skip it.
	    
		foreach my $e ( @$prevdim ) {
		    next DIM if $d == $e;
		}
	    
		# If we get this far, then it's a new dimension and we need to
		# open it!
	    
		my $this_indent = $indent + $context->{dim_indent};
		my $dim_varname = '$' . $rpkg . '_DIM_' . $d->{name};
		my $stmt = "foreach $dim_varname (";
	    
		if ( $d->{select} eq 'setv' ) {
		    $stmt .= '@{' . $d->{name} . '->{values}}';
		} elsif ( $d->{select} eq 'size' ) {
		    $stmt .= "0..$d->{end}";
		} else		# $d->{select} eq 'range'
		{
		    $stmt .= "$d->{start}..$d->{end}";
		}
		
		$stmt .= ')';
		
		$self->add_lines($phase, $this_indent, $stmt, '{');
		$context->{dim_indent}++;
		push @{$context->{dimlist}}, $d;
	    }
	}
    }
    
    # Otherwise, we check to see whether the current context covers all of the
    # necessary dimensions.  If not, we put in a runtime check.
    
    else
    {
	return unless ref $newdim eq 'ARRAY' and @$newdim > 0;
	
      DIM:
	foreach my $d ( @$newdim )
	{
	    # See if this dimension is in @$prevdim; if so, skip it.
	    
	    foreach my $e ( @$prevdim ) {
		next DIM if $d == $e;
	    }
	    
	    # If we get this far, then it's a new dimension and we need to
	    # check it!
	    
	    my $dim_varname = '$' . $rpkg . '_DIM_' . $d->{name};
	    my $stmt = "Mad::Runtime::error('$rpkg', 'missing dimension: $d->{name}', '$node->{filename} line $node->{line}') unless defined " . $dim_varname . ';';
	    $self->add_lines($phase, $indent, $stmt);
	}
    }
}


# close_dims_perl ( $self, $context, $indent )
# 
# Close any loops associated with open dimensions for the current context (not
# inherited ones).  This is only necessary if $IMPLICIT_INDEX is true.

sub close_dims_perl {

    my ($self, $context, $indent) = @_;
    
    return unless $self->{implicit_index};
    
    # Check to see if there are any dimensions in $context->{dimlist}.  If so,
    # these need to be closed, in last-in-first-out order.
    
    my $olddim = $context->{dimlist};
    my $phase = $context->{phase};
    
    if ( scalar(@$olddim) > 0 )
    {
	for (my $i = $#$olddim; $i >= 0; $i--)
	{
	    my $this_indent = $indent + $context->{dim_indent} - 1;
	    $self->add_lines($phase, $this_indent, '}');
	    $context->{dim_indent}--;
	    pop @$olddim;
	}
    }
}


# generate_rate_expr_perl ( $node, $context )
# 
# Generate the code that will determine the rate for a single flow.

sub generate_rate_expr_perl {

    my ($self, $node, $context) = @_;
    
    # First unpack the node.
    
    my $flow_type = ref $node;
    my $name = $node->{attr};
    my $source_node = $node->{children}[0];
    my $sink_node = $node->{children}[1];
    my $rate_node = $node->{children}[2];
    my $rpk = $self->{runpkg};
    
    # First we evaluate the source and sink variables.
    
    my ($source_expr, $source_type, $source_dim, $source_units) =
	$self->generate_var_expr_perl($source_node, $context, '&');
    
    my ($sink_expr, $sink_type, $sink_dim, $sink_units) =
	$self->generate_var_expr_perl($sink_node, $context, '&');
    
    # Figure out the proper suffix for the flow name, if there is more than
    # one.
    
    $name ||= "flow";
    
    if ( exists $self->{flowname}{$name} ) {
	$name .= '_' . $self->{flowname}{$name}++;
    }
    else {
	$self->{flowname}{$name} = 1;
    }
    
    my ($flow_expr) = '$' . $self->{runpkg} . $name;
    
    $self->add_lines('DECL', 1, $flow_expr . ';   # flow');
    
    # Start by generating code that encodes the various properties of the flow.
    
    my ($trace_perl) = "\$${rpk}_FLOW{'$name'} = \$${rpk}_FLOW{'$flow_expr'} = { name => '$name', vexpr => '$flow_expr', decl_file => '$node->{filename}', decl_line => '$node->{line}', source => '$source_expr', source_type => '$source_type', sink => '$sink_expr', sink_type => '$sink_type' }";
    
    $self->add_lines('DBGI', 1, $trace_perl . ';');
    
    # Then generate code that calculates the flow rate.
    
    my ($rate_expr, $rate_type, $rate_dim, $rate_units);
    
    if ( $flow_type eq 'FLOW_0' )
    {
	($rate_expr, $rate_type, $rate_dim, $rate_units) =
	    $source_type->_prop_rate_code($context, $source_node, undef, 
					  $source_expr, $rate_node);
    }
    
    elsif ( $flow_type eq 'FLOW_1' )
    {
	($rate_expr, $rate_type, $rate_dim, $rate_units) = 
	    $sink_type->_prop_rate_code($context, $sink_node, undef,
					$sink_expr, $rate_node);
    }
    
    else # third alternative is 'FLOW'
    {
	($rate_expr, $rate_type, $rate_dim, $rate_units) =
	    $self->generate_expr_perl($rate_node, $context, 'root');
    }
    
    my ($rate_stmt) = "$flow_expr = $rate_expr;";
    
    $self->annotate('CALC', 0, $source_node);
    $self->add_lines('CALC', 1, $rate_stmt);
    
    # Check types and units.
    
    unless ( $rate_type eq 'Mad::Gen::num' or $rate_type eq 'Mad::Gen::int' )
    {
	$self->syntax_error($node, "flow '$name': rate must be numeric");
    }
    
    $self->check_units_assign($source_node, $source_units, $rate_units, $name);
    $self->check_units_assign($sink_node, $sink_units, $rate_units, $name);
    
    # Make sure that each of the endpoints is added to the pointtab and
    # pointlist.  The reason for having both of these is so that we have a list
    # of each endpoint exactly once, in the order in which they appear in the
    # code.
    
    unless ( $self->{pointtab}{$source_expr} ) {
	my $point_rec = { name => $source_expr, type => $source_type, 
			  dim => $source_dim, units => $source_units,
			  node => $source_node };
	$self->{pointtab}{$source_expr} = $point_rec;
	push @{$self->{pointlist}}, $source_expr;
    }
    
    unless ( $self->{pointtab}{$sink_expr} ) {
	my $point_rec = { name => $sink_expr, type => $sink_type,
			  dim => $sink_dim, units => $sink_units,
			  node => $sink_node };
	$self->{pointtab}{$sink_expr} = $point_rec;
	push @{$self->{pointlist}}, $sink_expr;
    }
    
    # Now create a record describing the flow and add it to the flow list.
    # Also index it by source and sink.  This will allow us to go through the
    # flow endpoints later and adjust the flows to take into account any
    # limits.
    
    my $flow_rec = { name => $name, expr => $flow_expr,
		     type => $rate_type, source => $source_expr,
		     sink => $sink_expr, dim => $rate_dim, units => $rate_units,
		     node => $node };
    
    push @{$self->{flowlist}}, $flow_rec;
    
    $self->{sourcetab}{$source_expr} ||= [];
    push @{$self->{sourcetab}{$source_expr}}, $flow_rec;
    
    $self->{sinktab}{$sink_expr} ||= [];
    push @{$self->{sinktab}{$sink_expr}}, $flow_rec;
}


# generate_flow_perl ( )
# 
# Generate the code for the flows.  This first involves adjusting the flow
# rates to fit any value limits that the endpoints may have.

sub generate_flow_perl {

    my ($self, $context) = @_;
    
    # Add a comment to delineate the flow section
    
    $self->add_lines('CALC', 1, '', '# Check flow bounds', '');
    
    # For each endpoint, we first generate a check to see whether it
    # imposes any constraints on the outflows and/or inflows.  An
    # example would be that the sum of the outflows from a Pool cannot
    # exceed its current value.
    
    foreach my $endpoint ( @{$self->{pointlist}} ) {
	
	my $var_expr = $self->{pointtab}{$endpoint}{name};
	my $class = $self->{pointtab}{$endpoint}{type};
	my $node = $self->{pointtab}{$endpoint}{node};
	
	my @c = $class->_bounds_code($context, $node, undef, $var_expr, 
				     $self->{sourcetab}{$endpoint},
				     $self->{sinktab}{$endpoint});
	
	$self->add_lines('CALC', 1, @c);
    }
    
    # Once all of these checks have been done, we generate the code to
    # actually adjust the endpoint values.
    
    $self->add_lines('CALC', 1, '', '# Carry out flows', '');
    
    foreach my $endpoint ( @{$self->{pointlist}} ) {
	
	my $var_expr = $self->{pointtab}{$endpoint}{name};
	my $class = $self->{pointtab}{$endpoint}{type};
	my $node = $self->{pointtab}{$endpoint}{node};
	
	my @c = $class->_flow_code($context, $node, undef, $var_expr, 
				   $self->{sourcetab}{$endpoint},
				   $self->{sinktab}{$endpoint});
	
	$self->add_lines('CALC', 1, @c);
    }
}


# generate_step_perl ( )
# 
# Generate the code that will perform the STEP phase.  This includes some
# declaration and initialization code for the variable $T.

sub generate_step_perl {

    my ($self) = @_;
    my ($rpkg) = $self->{runpkg};
    my ($rp) = $rpkg;
    $rp =~ s/::$//;
    
    $self->add_lines('USES', 0, "package $rp;");
    $self->add_lines('USES', 0, "use Mad::Runtime;");
    $self->add_lines('USES', 0, "use Mad::StandardRuntime;");
    $self->add_lines('DECL', 1, "\$${rpkg}START;", '# Simulation start value');
    $self->add_lines('DECL', 1, "\$${rpkg}END;", '# Simulation end value');
    $self->add_lines('DECL', 1, "\$${rpkg}I;", '# Step interval');
    $self->add_lines('DECL', 1, "\$${rpkg}T;", '# Primary step variable');
    $self->add_lines('STEP', 1, "\$${rpkg}T++;");
}

# generate_trace_perl ( )
# 
# Generate the code that will record the values of variables at each step so
# that they can be plotted later.  This routine will be called once after the
# INIT phase, and once after each STEP phase.

sub generate_trace_perl {
    
    my ($self) = @_;
    
    my $rpk = $self->{runpkg};
    
    # NEED TO ADD: OTHER TARGETS $$$$
    
    # Start by getting a list of all flow-endpoint variables.  For now, these
    # are the only ones we'll trace [NEED TO ADD: mechanism for specifying
    # that other variables be traced]
    
    my $base = '$' . $rpk . '_TRACE';
    
    my $tinit_perl = $base . "{'T'} = [];\n";
    $self->add_lines('INIT', 1, $tinit_perl);
    
    my $time_perl = 'push @{' . $base . "{'T'}}, \$${rpk}T;\n";
    $self->add_lines('TRAC', 1, $time_perl);
    
    
    #foreach my $var_name ( @{$self->{varlist}} ) {
	
#	my $name = $ep->{name};
#	my $type = $ep->{type};
#	my $node = $ep->{nodelist}[0];
#	my $class = "Mad::Gen::$type";
	
#	next if $type eq 'num';
	
	#my $value_code = $class->_value_code($target, $self, $node, 
	#				   '$' . $name, 'value');
	#
	#my $trace_name = $name;
	#$trace_name =~ s/^\$?\w+:://;
	#
	#my $init_perl = "    $base" . "{'$trace_name'} = [];\n";
	#$self->add_code('INIT', $init_perl);
	#
	#my $trace_perl = '    push @{' . $base . "{'$trace_name'}}, $value_code;\n";	
	#$self->add_code('TRAC', $trace_perl);
#    }
}


# annnotate_perl ( $node )
# 
# Return a special comment string that marks the original source file and line
# to which the next line of generated code best corresponds.  This should
# enable the debugger to show us the original source line whenever possible.

sub annotate_perl {
    
    my ($self, $node) = @_;
    
    return '#line ' . $node->{line} . ' ' . $node->{filename};
}


# load_perl ( $objname )
# 
# Load Perl code from the given filename, preparing us to run the model
# expressed therein.  Returns true on success, false otherwise.

sub load_perl {
    
    my ($self, $objname) = @_;
    
    # We read back the generated Perl code via the 'require' operator, which
    # causes it to be compiled to an executable state.  We then save
    # references to the subroutines which execute each of the phases, so that
    # the Mad::Runtime module can call them as appropriate in order to run the
    # model.
    
    # We set the $LOADING flag, which suppresses immediate execution of the
    # generated code.
    
    eval '$' . $self->{runpkg} . 'LOADING = 1;';
    
    require $objname;
    
    $self->{init_sub} = eval '\&' . $self->{runpkg} . 'init_sub;';
    $self->{calc_sub} = eval '\&' . $self->{runpkg} . 'calc_sub;';
    $self->{step_sub} = eval '\&' . $self->{runpkg} . 'step_sub;';
    $self->{fini_sub} = eval '\&' . $self->{runpkg} . 'fini_sub;';
    $self->{trac_sub} = eval '\&' . $self->{runpkg} . 'trac_sub;';
    $self->{time_var} = eval '\$' . $self->{runpkg} . 'T;';
    
    eval '$' . $self->{runpkg} . 'LOADING = 0;';
    
    $self->{status} = 'READY';
    return 1;
};

1;
