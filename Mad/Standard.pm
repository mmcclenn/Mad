#
# Mad Project
# 
# Standard object definitions
# 
# Author: Michael McClennen
# Copyright (c) 2010 University of Wisconsin-Madison
# 
# This file defines a series of object classes that form a base set
# available to Mad programmers.
# 
# For each class, we implement a standard set of class methods that
# the Mad compiler will use to create the proper code for interacting
# with instances of these objects.  These class method names all start
# with an underscore (_).  Method names that do not start with an
# underscore are object methods, intended to be called directly in Mad
# code and in the code generated by the Perl backend.

# Each class must offer the following methods.  Each one gets the following
# four common parameters: $context, $node, $subtype, $var_expr.  The first of
# these ($context) is a reference to the head of a linked chain of symbol
# tables, which is used to evaluate other names in the process of generating
# code.  These symbol tables also store a reference to the model and to the
# target language.  The next ($node) is a reference to the parse tree node
# representing the object whose code is being benerated.  The third ($subtype)
# is typically empty, except for parametrized types.  In that case, it will
# contain a list of one or more subtypes.  For example, the type for a "list
# of integers" is "Mad::Gen::list<Mad::Gen::int>".  The class on which
# _declare_code, _value_code, etc. is called will be Mad::Gen::list, and the
# $subtype parameter will be Mad::Gen::int.  The last parameter ($var_expr) is
# an expression representing the variable in the target language, which is
# used as a base for the generated code.
# 
# These methods are called with the indicated additional parameters:
# 
#   _declare_code ( ... $var_expr )
#   
#      Return code that declares a variable of this type.
#   
#   _init_code ( ... $var_expr, @attrs )
#      
#      Return code that initializes a variable of this type.  If @attrs is not
#      empty, it should be a list of alternating attribute names and value
#      expressions.  The initial value (if any) should be given using the
#      attribute 'value'.
# 
#   _value_code ( ... $var_expr, $attr, $type )
#      
#      Return code that evaluates to the primary value of the specified object
#      (if $attr is 'value') or to the named attribute otherwise.
#      
#   _set_code ( ... $var_expr, $attr, $type, $op, $value )
#      
#      Return code that evaluates to an expression that sets the primary value
#      of the specified object (if $attr is 'value') or the named attribute
#      otherwise.  The parameter $op can be any of '=', '+=', '*=', etc.
# 
#   _metcall_code ( ... $var_expr, $method_name, @params )
# 
#      Return code that makes a method call on the specified object.
# 
# Note that the class must also implement each method (i.e. 'new',
# 'set_foobar', etc.) that may be mentioned in the code returned by
# these four methods.
# 
# In addition, each class that is available for use as the endpoint of
# a flow must also define or inherit the following methods:
# 
#   _prop_rate_code
#   _preflow_code
#   _bounds_code
#   _flow_code
#   _postflow_code
# 


use strict;

#=============================================================================
# 
# We start out by defining the class for scalar variables:
#
#    Scalar
# 
# We treat primitive types using the same system of methods (detailed above)
# as object types.  This simplifies the compilation process quite a bit.

package Mad::Gen::Scalar;


# Generate code to declare a scalar variable.

# NOTE: The existence of a _declare_code_<target> method for a particular
# target language is taken to be a marker that this target is able to be used.

sub _declare_code {

    my ($class, $context, $node, $subtype, $var_dim, $var_expr) = @_;
    
    # We ignore the object's attributes in declaring it; those are only needed
    # when initializing the object.
    
    # We call the appropriate method to generate the target code, or
    # complain if no such method exists.
    
    my $target = '_declare_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_dim, $var_expr);
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _declare_code_perl {

    my ($class, $context, $node, $subtype, $var_dim, $var_expr) = @_;
    
    # For Perl, there is nothing to declare so we can just return the
    # variable's name.
    
    return $var_expr;
}

our (%CC_TYPE_MAP) = ( 'Mad::Gen::num' => 'double',
		       'Mad::Gen::int' => 'int',
		       'Mad::Gen::flag' => 'bool',
		       'Mad::Gen::string' => 'String',
		       'Mad::Gen::general' => 'General' );

sub _declare_code_cc {

    my ($class, $context, $node, $subtype, $var_dim, $var_expr) = @_;
    
    my $cc_type = $CC_TYPE_MAP{$subtype};
    
    return "$cc_type& $var_expr";
}


# Generate code to initialize a scalar variable.  The @attrs parameter is our
# generic method for conveying the attributes to be used in the
# initialization.  The only attribute that this class and its subclasses
# accept is 'value', which provides the initial value.

sub _init_code {

    my ($class, $context, $node, $subtype, $var_expr, @attrs) = @_;
    
    # First check the attrs.  'value' is the only one this class
    # accepts, and it specifies the initial value of the declared variable.
    
    my $value_node;
    
    while (@attrs)
    {
	my $attr = shift @attrs;
	if ( $attr eq 'value' ) {
	    $value_node = shift @attrs;
	}
	else {
	    $context->syntax_error($node, "$class: Unknown attribute: '$attr'");
	    return '**ERROR**';
	}
    }
    
    # Then evaluate the value expression, and make sure that the type of the
    # initialization expression is compatible with the type of the variable
    # being initialized.
    
    my ($value_expr, $value_type, $value_dim, $value_units) = 
	$context->evaluate($value_node, 'root');
    
    $context->check_types($node, $subtype, $value_type, '=', 'value');
    
    $context->check_units($node, $node->{units}, $value_units, $node->{attr});
    
    $value_expr = $context->transform_type($value_expr, $value_type, 
					   $subtype);
    
    # Now, call the appropriate function to generate the target-language
    # initialization code.  Actually, this only generates part of the code;
    # the result of this function is processed further before it is added to
    # the model.
    
    my $target = '_init_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, 
			       $value_expr, $value_type);
    }
    
    # If no such method exists, signal an error.
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}

sub _init_code_perl {

    my ($class, $context, $node, $subtype, $var_expr, 
	$value_expr, $value_type) = @_;
    
    $value_expr = 'undef' if $value_expr eq '';
    
    return "$var_expr = $class" . 
	"->new('$subtype', '$node->{attr}', $value_expr)";
}

sub _init_code_cc {

    my ($class, $context, $node, $subtype, $var_expr, 
	$value_expr, $value_type) = @_;
    
    # The value expression starts with a statement allocating memory for the
    # variable.

    my ($cc_type) = $CC_TYPE_MAP{$subtype};
    my ($init_expr) = "$var_expr = new $cc_type";
    
    # If an initialization value is given, we use transform_type to alter the
    # value expression appropriately and add an assignment statement to the
    # initialization expression.
    
    if ( $value_expr ne '' )
    {
	$value_expr = $context->transform_type($value_expr, $value_type,
					       $subtype);
	$init_expr .= "; *$var_expr = $value_expr";
    }
    
    return $init_expr;
}


# Generate code that will set the value of a scalar variable.  $op
# can be any of '=', '+=', '-=', etc.  It can also be ':=', which rebinds the
# object's name to another object.

sub _set_code {

    my ($class, $context, $node, $subtype, $var_expr, 
	$attr, $op, $value_node) = @_;
    
    my ($short_op);
    
    # First check to make sure we are setting a recognized attribute.
    
    if ( $attr ne '' and $attr ne 'value' )
    {
	$context->syntax_error($node, "$class: unknown attribute '$attr'");
    }
    
    if ( $attr ne '' and $op eq ':=' )
    {
	$context->syntax_error($node, "$class: bind/value conflict");
    }
    
    # Then decide whether we are setting the value or binding the name.
    
    my ($select) = $op eq ':=' ? 'bind' : 'root';
    
    # Now evaluate the value expression, and make sure that the type of the
    # value expression is compatible with the type of the variable
    # whose value is being set.
    
    my ($value_expr, $value_type, $value_dim, $value_units) = 
	$context->evaluate($value_node, $select);
    
    $context->check_types($node, $subtype, $value_type, $op, 'value');
    
    # If the operator is not appropriate to the value type, signal an error or
    # modify the operator.
    
    if ( $subtype eq 'Mad::Gen::int' and $value_type ne 'int' and ($op eq '/=' || $op eq '.='))
    {
	($short_op, $op) = split('', $op);
	$value_expr = "int($var_expr $short_op int($value_expr))";
    }
    
    elsif ( $subtype eq 'Mad::Gen::flag' and $op =~ /[-+*\/^]=/ )
    {
	$context->syntax_error($node, "you cannot use the operator '$op' with a flag variable");
    }
    
    elsif ( $subtype eq 'Mad::Gen::string' and $op =~ /[-+*\/^]=/ )
    {
	$context->syntax_error($node, "you cannot use the operator '$op' with a flag variable");
    }
    
    # Finally, call the appropriate method to generate the target code
    
    my $target = '_set_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $subtype, $node, $var_expr, $attr, 
			       $op, $value_expr, $value_type),
			   $subtype, $value_dim, $value_units;
    }
    
    # If no such method exists, signal an error.
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _set_code_perl {

    my ($class, $context, $subtype, $node, $var_expr, $attr, $op, 
	$value_expr, $value_type) = @_;
    
    # If we are rebinding, we change where the variable points.
    
    if ( $op eq ':=' )
    {
	return $var_expr . ' = ' . $value_expr;
    }
    
    # Otherwise, we dereference the variable and change the value to which it
    # points. 
    
    else 
    {
	$value_expr = $context->transform_type($value_expr, $value_type,
					       $subtype);
	return $var_expr . "->{value} $op " . $value_expr;
    }
}


sub _set_code_cc {

    my ($class, $context, $subtype, $node, $var_expr, $attr, $op, 
	$value_expr, $value_type) = @_;
    
    # If we are rebinding, we change where the variable points.
    
    if ( $op eq ':=' )
    {
	return $var_expr . ' = ' . $value_expr;
    }
    
    # Otherwise, we dereference the variable and change the value to which it
    # points. 
    
    else 
    {
	$value_expr = $context->transform_type($value_expr, $value_type,
					       $subtype);
	return '*' . $var_expr . ' = ' . $value_expr;
    }
}


# Generate code that will provide the value of a scalar variable.

sub _value_code {

    my ($class, $context, $node, $subtype, $var_expr, $attr) = @_;
    
    # First check the attribute.  The only one accepted is 'value',
    # which produces the variable's value.
    
    if ( $attr ne 'value' )
    {
	$context->syntax_error($node, "$class: unknown attribute '$attr'");
	return '**ERROR**';
    }
    
    # Finally, call the appropriate method to generate the target code.
    
    my $target = '_value_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $subtype, $node, $var_expr), $subtype;
    }
    
    # If no such method exists, signal an error.
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}

sub _value_code_perl {
    
    my ($class, $context, $subtype, $node, $var_expr) = @_;
    
    # Generate code that dereferences the variable.
    
    return $var_expr . '->{value}';
}

sub _value_code_cc {
    
    my ($class, $context, $subtype, $node, $var_expr) = @_;
    
    # Generate code that dereferences the variable.
    
    return '*' . $var_expr;
}


# Return true if this type can be used in a context that requires a value.
# Always true for this type.

sub _has_value {

    return 1;
}


# Generate code that will execute a method call on a scalar variable.

sub _metcall_code {

    my ($class, $context, $node, $subtype, $var_expr, $method_name) = @_;
    
    $context->syntax_error($node, "$class: not an object");
    return '**ERROR**';
}


#=============================================================================
# 
# Then we define the data type for list variables:
#
#    List
# 
# By "compound" we mean that this type is parametrized by another type.  You
# can define a list of integers ("Mad::Gen::list<Mad::Gen::int>") or a list of
# Pools ("Mad::Gen::list<Mad::Gen::Pool>"), etc.

package Mad::Gen::List;


# Generate code to declare a variable of type Mad::Gen::list.

sub _declare_code {

    my ($class, $context, $node, $subtype, $var_expr, $dimlist) = @_;
    
    # We call the appropriate method to generate the target code, or
    # complain if no such method exists.
    
    my $target = '_declare_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $dimlist),
	    "$class<$subtype>";
    }
    
    else {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _declare_code_perl {

    my ($class, $context, $node, $subtype, $var_expr, $dimlist) = @_;
    
    return "$var_expr = bless [], 'Mad::Gen::List'";
}


# Generate code to initialize a variable of type Mad::Gen::list

sub _init_code {

    my ($class, $context, $node, $subtype, $var_expr, @attrs) = @_;
    
    # First check the attrs.  'value' is the only one this class
    # accepts, and it specifies the initial value of the declared variable.
    
    my $value_node;
    
    while (@attrs)
    {
	my $attr = shift @attrs;
	if ( $attr eq 'value' ) {
	    $value_node = shift @attrs;
	}
	else {
	    $context->syntax_error($node, "$class: Unknown attribute: '$attr'");
	    return '**ERROR**';
	}
    }
    
    # Evaluate the value and check types and units.
    
    my ($value_expr, $value_type, $value_dim, $value_units) =
	$context->evaluate($value_node, 'root');
    
    $context->check_types($node, "$class<$subtype>", $value_type, '=', 
			  'list value');
    $context->check_units($node, $node->{units}, $value_units, 'list value');
    
    # Now call the appropriate method to generate the target code, or
    # generate generic code if no such method exists.
    
    my $target = '_init_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, 
			       $value_expr, $value_type);
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _init_code_perl {

    my ($class, $context, $node, $subtype, $var_expr, $value_expr,
	$value_type) = @_;
    
    return "$var_expr = $class" . 
	"->new('$subtype', '$node->{attr}', $value_expr)";
}


# Generate code that will set the value of a list variable.  $op can be any of
# '=', '+=', '-=', etc.  It can also be ':=', which rebinds the object's name
# to another object.

sub _set_code {

    my ($class, $context, $node, $subtype, $var_expr, $attr, $op, 
	$value_node) = @_;
    
    if ( $attr ne '' and $attr ne 'value' )
    {
	$context->syntax_error($node, "$class: unknown attribute '$attr'");
	return '**ERROR**';
    }
    
    # We haven't implemented re-binding of variables yet.
    
    elsif ( $op eq ':=' )
    {
	$context->syntax_error($node, "rebinding is not implemented yet.");
	return '**ERROR**';
    }
    
    # Most operators aren't allowed for lists.
    
    elsif ( $op ne '=' and $op ne '+=' )
    {
	$context->syntax_error($node, "operator '$op' is not allowed for lists");
    }
    
    # Now evaluate the value expression and check type and units.
    
    my ($value_expr, $value_type, $value_dim, $value_units) = 
	$context->evaluate($value_node, 'root');
    
    $context->check_types($node, "$class<$subtype>", $value_type, $op, 'list value');
    $context->check_units($node, $node->{units}, $value_units, 'list value');
    
    # Call the appropriate method to generate target code.
    
    my $target = '_set_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, 
			       $attr, $op, $value_expr, $value_type),
				   "$class<$subtype>", undef, $node->{units};
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _set_code_perl {
    
    my ($class, $context, $node, $subtype, $var_expr, $attr, $op, 
	$value_expr, $value_type) = @_;
    
    # If we're assigning something other than an integer or list or set of
    # integers to an integer list, we need to use the int_list function.
    # Similarly for booleans with flag_list.
    
    if ( $subtype eq 'Mad::Gen::int' and $value_type !~ /Mad::Gen::int\b/ )
    {
	$value_expr = "int_list($value_expr)";
    }
    
    elsif ( $subtype eq 'Mad::Gen::flag' and $value_type !~ /Mad::Gen::flag\b/ )
    {
	$value_expr = "flag_list($value_expr)";
    }
    
    elsif ( $subtype eq 'Mad::Gen::string' and $value_type !~ /Mad::Gen::string\b/ )
    {
	$value_expr = "string_list($value_expr)";
    }
    
    elsif ( $subtype eq 'Mad::Gen::num' and $value_type !~ /Mad::Gen::num\b/ )
    {
	$value_expr = "num_list($value_expr)";
    }
    
    if ( $op eq '=' )
    {
	return '@{' . $var_expr . "} = $value_expr";
    }
    
    else # $op eq '+='
    {
	return 'push @{' . $var_expr . "}, $value_expr";
    }
}


our (%ATTR_TYPE) = ( value => '@',
		     length => 'int',
		     last => 'int' );

# Generate code which will return the value of a variable of type
# Mad::Gen::list, or of one of its attributes.

sub _value_code {
    
    my ($class, $context, $node, $subtype, $var_expr, $attr) = @_;
    
    # First check the attribute.  This type accepts 'value' and 'length'.
    
    unless ( defined $ATTR_TYPE{$attr} )
    {
	$context->syntax_error($node, "$class: unknown attribute '$attr'");
	return '**ERROR**';
    }
    
    my ($value_type) = $ATTR_TYPE{$attr};
    
    # If a method exists to generate code for the specified target,
    # call it.  Otherwise, signal an error.
    
    my $target = '_value_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $attr),
	    $value_type;
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _value_code_perl {

    my ($class, $context, $node, $subtype, $var_expr, $attr) = @_;
    
    if ( $attr eq 'length' )
    {
	return 'scalar(@{' . $var_expr . '})';
    }
    
    elsif ( $attr eq 'last' )
    {
	return '$#{' . $var_expr . '}';
    }
    
    else
    {
	return '@{' . $var_expr . '}';
    }
}


# Return true if this type can be used in a context that requires a value.
# Always true for this type.

sub _has_value {

    return 1;
}


# Generate code to execute a method call on a list variable.  Actually, the
# only method currently defined is elt(), which is compiled into a method-less
# subscript expression.

sub _metcall_code {

    my ($class, $context, $node, $subtype, $var_expr, $method, @arg_nodes) = @_;
    
    # First check the method name.  This type accepts 'elt'.
    
    if ( $method ne 'elt' )
    {
	$context->syntax_error($node, "$class: unknown method '$method'");
    }
    
    elsif ( @arg_nodes > 1 )
    {
	$context->syntax_error($node, "$class: too many parameters for '$method'");
    }
    
    elsif ( @arg_nodes < 1 )
    {
	$context->syntax_error($node, "$class: missing parameter for '$method'");
    }
    
    # Now evaluate the argument and check types.
    
    my ($arg_expr, $arg_type, $arg_dim) = 
	$context->evaluate($arg_nodes[0], 'root');
    
    if ( $arg_type ne 'Mad::Gen::int' )
    {
	$context->syntax_error($node, "$class: argument to 'elt' must be an integer");
    }
    
    # If a method exists to generate code for the specified target,
    # call it.  Otherwise, signal an error.
    
    my $target = '_metcall_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $method,
			       $arg_expr), $subtype;
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _metcall_code_perl {
    
    my ($class, $context, $node, $subtype, $var_expr, $method, $arg_expr) = @_;
    
    # We only need to evaluate the first argument, because no method of this
    # class allows more than one argument.
    
    return $var_expr . '->[' . $arg_expr . ']';
}


#=============================================================================
# 
# Next, the data type for sets:
#
#    set
# 
# This is also a parametrized type.  You can define a set of integers
# ("Mad::Gen::set<Mad::Gen::int>") or a set of Pools
# ("Mad::Gen::set<Mad::Gen::Pool>"), etc.

package Mad::Gen::Set;


# Generate code to declare a variable of type Mad::Gen::set.

sub _declare_code {

    my ($class, $context, $node, $subtype, $var_expr, $dimlist) = @_;
    
    # We call the appropriate method to generate the target code, or
    # complain if no such method exists.
    
    my $target = '_declare_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $dimlist),
	    "$class<$subtype>";
    }
    
    else {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _declare_code_perl {

    my ($class, $context, $node, $subtype, $var_expr, $dimlist) = @_;
    
    return "$var_expr = bless { order => [], hash => {} }, 'Mad::Gen::Set'";
}


# Generate code to initialize a variable of type Mad::Gen::set

sub _init_code {

    my ($class, $context, $node, $subtype, $var_expr, @attrs) = @_;
    
    # First check the attrs.  'value' is the only one this class
    # accepts, and it specifies the initial value of the declared variable.
    
    my $value_node;
    
    while (@attrs)
    {
	my $attr = shift @attrs;
	if ( $attr eq 'value' ) {
	    $value_node = shift @attrs;
	}
	else {
	    $context->syntax_error($node, "$class: Unknown attribute: '$attr'");
	    return '**ERROR**';
	}
    }
    
    # Evaluate the value expression and check types and units.
    
    my ($value_expr, $value_type, $value_dim, $value_units) = 
	$context->evaluate($value_node, 'root');
    
    $context->check_types($node, "$class<$subtype>", $value_type, '=', 'value list');
    $context->check_units($node, $node->{units}, $value_units, 'value list');
    
    # Now call the appropriate method to generate the target code, or
    # signal an error if no such code exists.
    
    my $target = '_init_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, 
			       $value_expr, $value_type);
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _init_code_perl {

    my ($class, $context, $node, $subtype, $var_expr, $value_expr,
       $value_type) = @_;
    
    $value_expr = 'undef' if $value_expr eq '';
    
    return "$var_expr = $class" . 
	"->new('$subtype', '$node->{attr}', $value_expr)";
}


# Generate code that will set the value of a variable of type Mad::Gen::set.
# $op can be any of '=', '+=', '-=', etc.  It can also be ':=', which rebinds
# the object's name to another object.

sub _set_code {

    my ($class, $context, $node, $subtype, $var_expr, $attr, $op, 
	$value_node) = @_;
    
    if ( $attr ne '' and $attr ne 'value' )
    {
	$context->syntax_error($node, "$class: unknown attribute '$attr'");
	return '**ERROR**';
    }
    
    # We haven't implemented re-binding of variables yet.
    
    elsif ( $op eq ':=' )
    {
	$context->syntax_error($node, "rebinding is not implemented yet.");
	return '**ERROR**';
    }
    
    elsif ( $op ne '=' )
    {
	$context->syntax_error($node, "operator '$op' is not allowed with sets");
	return '**ERROR**';
    }
    
    # Evaluate the value expression and check types and units.
    
    my ($value_expr, $value_type, $value_dim, $value_units) = 
	$context->evaluate($value_node, 'root');
    
    $context->check_types($node, "$class<$subtype>", $value_type, $op, 'value list');
    $context->check_units($node, $node->{units}, $value_units, 'value list');
    
    # Now call the appropriate method to generate the target code.
    
    my $target = '_set_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, 
			       $attr, $op, $value_expr, $value_type),
				   "$class<$subtype>";
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _set_code_perl {
    
    my ($class, $context, $node, $subtype, $var_expr, $attr, $op, 
	$value_expr, $value_type) = @_;
    
    # If we're assigning something other than an integer or list or set of
    # integers to an integer list, we need to use the int_list function.
    # Similarly for booleans with flag_list.
    
    if ( $subtype eq 'Mad::Gen::int' and $value_type !~ /Mad::Gen::int\b/ )
    {
	$value_expr = "int_list($value_expr)";
    }
    
    elsif ( $subtype eq 'Mad::Gen::flag' and $value_type !~ /Mad::Gen::flag\b/ )
    {
	$value_expr = "flag_list($value_expr)";
    }
    
    elsif ( $subtype eq 'Mad::Gen::string' and $value_type !~ /Mad::Gen::string\b/ )
    {
	$value_expr = "string_list($value_expr)";
    }
    
    elsif ( $subtype eq 'Mad::Gen::num' and $value_type !~ /Mad::Gen::num\b/ )
    {
	$value_expr = "num_list($value_expr)";
    }
    
    return $var_expr . "->set_value($value_expr)";
}


# Generate code which will return the value of a variable of type
# Mad::Gen::set, or of one of its attributes.

sub _value_code {
    
    my ($class, $context, $node, $subtype, $var_expr, $attr) = @_;
    
    # First check the attribute.  This type accepts 'value' and 'length'.
    
    if ( $attr ne 'value' and $attr ne 'length' )
    {
	$context->syntax_error($node, "$class: unknown attribute '$attr'");
	return '**ERROR**';
    }
    
    my ($value_type) = ($attr eq 'length' ? 'Mad::Gen::int' : "$class<$subtype>");
    
    # If a method exists to generate code for the specified target,
    # call it.  Otherwise, signal an error.
    
    my $target = '_value_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $attr),
	    $value_type;
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _value_code_perl {

    my ($class, $context, $node, $subtype, $var_expr, $attr) = @_;
    
    if ( $attr eq 'length' )
    {
	return 'scalar(@{' . $var_expr . '->{order}})';
    }
    
    else
    {
	return '@{' . $var_expr . '->{order}}';
    }
}


# Return true if this type can be used in a context that requires a value.
# Always true for this type.

sub _has_value {

    return 1;
}


# Generate code to execute a method call on a set variable.  Actually, the
# only method currently defined is elt(), which is compiled into a method-less
# subscript expression.

sub _metcall_code {

    my ($class, $context, $node, $subtype, $var_expr, $method, @arg_nodes) = @_;
    
    # First check the method name.  This type accepts 'elt'.
    
    if ( $method ne 'elt' )
    {
	$context->syntax_error($node, "$class: unknown method '$method'");
    }
    
    elsif ( @arg_nodes > 1 )
    {
	$context->syntax_error($node, "$class: too many parameters for '$method'");
    }
    
    elsif ( @arg_nodes < 1 )
    {
	$context->syntax_error($node, "$class: missing parameter for '$method'");
    }
    
    # Now evaluate the argument and check types.
    
    my ($arg_expr, $arg_type, $arg_dim) = 
	$context->evaluate($arg_nodes[0], 'root');
    
    if ( $arg_type ne 'Mad::Gen::int' )
    {
	$context->syntax_error($node, "$class: argument to 'elt' must be an integer");
    }
    
    # If a method exists to generate code for the specified target,
    # call it.  Otherwise, signal an error.
    
    my $target = '_metcall_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $method,
			       $arg_expr);
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _metcall_code_perl {
    
    my ($class, $context, $node, $subtype, $var_expr, $method, $arg_expr) = @_;
    
    # We only need to evaluate the first argument, because no method of this
    # class allows more than one argument.
    
    return $var_expr . '->{order}[' . $arg_expr . ']';
}


#=============================================================================
# 
# Now, we have the base class for classes defined by Mad programs:
#
#    MadClass
# 
# This class is purely virtual, existing only to provide methods to its
# subclasses.

package Mad::Gen::MadClass;


# Generate code to declare a variable of a type (class or structure) that
# is itself defined in a Mad model.

sub _declare_code {
    
    my ($class, $context, $node, $subtype, $var_expr, $dimlist) = @_;
    
    # Call the appropriate method to generate the target code, or complain if
    # no such method exists.
    
    my $target = '_declare_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $dimlist);
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _declare_code_perl {
    
    my ($class, $context, $node, $subtype, $var_expr, $dimlist) = @_;
    
    return $var_expr;
}


# Generate code to initialize the value of a variable of a model-defined type.

sub _init_code {

    my ($class, $context, $node, $subtype, $var_expr, @init_nodes) = @_;
    
    # Evaluate each of the arguments in turn.
    
    my $argstring = '';
    
    foreach my $n ( @init_nodes )
    {
	my ($arg_expr, $arg_type, $arg_dim, $arg_units) =
	    $context->evaluate($n, 'root');
	
	# $$$ Need to handle argument dimension, type and units!!!
	
	$argstring .= ', ' if $argstring ne '';
	$argstring .= $arg_expr;
    }
    
    # Call the appropriate method to generate the target code, or complain if
    # no such method exists.
    
    my $target = '_init_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, 
			       $argstring);
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _init_code_perl {
    
    my ($class, $context, $node, $subtype, $var_expr, $argstring) = @_;
    
    # Generate code to create a new object in the class.
    
    return $var_expr . " = $class" . "->new('$argstring')";
}


# Generate code to get the value of a variable of a type defined in a Mad
# model.

sub _set_code {
    
    my ($class, $context, $node, $subtype, $var_expr, $attr, $op, $value_node) = @_;
    
    # First make sure that the given attribute is actually defined for this
    # type. 
    
    my $model = $context->model();
    my $class_rec = $model->lookup_static($class);
    
    unless ( exists $class_rec->{sym}{$attr} ) {
	$model->syntax_error($node, "$class: unknown attribute '$attr'");
	return '**ERROR**';
    }
    
    unless ( $class_rec->{sym}{$attr}{kind} eq 'ATTR' ) {
	$model->syntax_error($node, "$class: '$attr' is not an attribute");
	return '**ERROR**';
    }
    
    # Then decide whether we are setting the value or binding the name.
    
    my ($select) = $op eq ':=' ? 'bind' : 'root';
    
    # Now look up the attribute's type, and then evaluate the value expression
    # and check types and units.
    
    my $attr_type = $class_rec->{sym}{$attr}{type};
    my $attr_units = $class_rec->{sym}{$attr}{units};
    
    my ($value_expr, $value_type, $value_dim, $value_units) = 
	$context->evaluate($value_node, $select);
    
    $context->check_types($node, $attr_type, $value_type, $op, $attr);
    $context->check_units($node, $attr_units, $value_units, $attr);
    
    # Call the appropriate method to generate the target code.
    
    my $target = '_set_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $attr,
			       $attr_type, $op, $value_expr, $value_type),
				   $attr_type, $value_dim, $attr_units;
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _set_code_perl {
    
    my ($class, $context, $node, $subtype, $var_expr, $attr, $attr_type, $op, 
	$value_expr, $value_type) = @_;
    
    if ( $attr_type eq 'Mad::Gen::int' and $value_type ne 'Mad::Gen::int' )
    {
	$value_expr = "int($value_expr)";
    }
    
    elsif ( $attr_type eq 'Mad::Gen::flag' and $value_type ne 'Mad::Gen::flag' )
    {
	$value_expr = "($value_expr ? 1 : 0)";
    }
    
    elsif ( $attr_type eq 'Mad::Gen::string' and $value_type ne 'Mad::Gen::string' )
    {
	$value_expr = "'' . $value_expr";
    }
    
    elsif ( $attr_type eq 'Mad::Gen::num' and $value_type ne 'Mad::Gen::num' )
    {
	$value_expr = "0.0 + $value_expr";
    }
    
    return $var_expr. "->{$attr}" . " $op $value_expr";
}


# Generate code to get the value of an attribute of a variable of a type
# defined in a Mad model.

sub _value_code {
    
    my ($class, $context, $node, $subtype, $var_expr, $attr) = @_;
    
    # First make sure that the given attribute is actually defined for this
    # type. 
    
    my $model = $context->model();
    my $class_rec = $model->lookup_static($class);
    
    unless ( exists $class_rec->{sym}{$attr} ) {
	$model->syntax_error($node, "$class: unknown attribute '$attr'");
	return '**ERROR**';
    }
    
    unless ( $class_rec->{sym}{$attr}{kind} eq 'ATTR' ) {
	$model->syntax_error($node, "$class: '$attr' is not an attribute");
	return '**ERROR**';
    }
    
    # Now look up the attribute's type and units.
    
    my $attr_type = $class_rec->{sym}{$attr}{type};
    my $attr_units = $class_rec->{sym}{$attr}{units};
    
    # If a method exists to generate code for the specified target, call it.
    # Otherwise, the default code is the simple expression "var.attr op value"
    # that will do the trick in almost every common language (i.e. var.attr =
    # value, var.attr += value, etc.)
    
    my $target = '_value_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $attr),
	    "$attr_type", undef, $attr_units;
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _value_code_perl {
    
    my ($class, $context, $node, $subtype, $var_expr, $attr) = @_;
    
    return $var_expr . "->{$attr}";
}


# Return true if this type can be used in a context that requires a value.
# Always false for this type.

sub _has_value {

    return 0;
}


# Generate code for a method call

sub _metcall_code {
    
    my ($class, $context, $node, $subtype, $var_expr, $method, @arg_nodes) = @_;
    
    # First make sure that the given attribute is actually defined for this
    # type. 
    
    my $model = $context->model();
    my $class_rec = $model->lookup_static($class);
    
    unless ( exists $class_rec->{sym}{$method} and
	     $class_rec->{sym}{$method}{kind} eq 'METHOD' )
    {
	$model->syntax_error($node, "$class: '$method' is not a method of this class");
	return '**ERROR**';
    }
    
    # Now look up the method's type and units.
    
    my $met_sig = $class_rec->{sym}{$method}{sig};
    my $met_type = $class_rec->{sym}{$method}{type};
    my $met_units = $class_rec->{sym}{$method}{units};
    
    # Then evaluate the arguments and check types and units.
    
    my @signature = @$met_sig;
    
    my $arg_string = '';
    my $pnum = 1;
    
    foreach my $n ( @arg_nodes )
    {
	my ($arg_expr, $arg_type, $arg_dim, $arg_units) = 
	    $context->evaluate($n, 'root');
	
	unless ( @signature )
	{
	    $context->syntax_error($node, "too many parameters for method '$method'");
	    return '**ERROR**';
	}
	
	my $p_type = shift @signature;
	my $p_units = shift @signature;
	
	$context->check_types($node, $p_type, $arg_type, '=', $pnum);
	$context->check_units($node, $p_units, $arg_units, $pnum++);
	
	$arg_string .= ', ' if $arg_string;
	$arg_string .= $arg_expr;
    }
    
    # If a method exists to generate code for the specified target,
    # call it.  Otherwise, signal an error.
    
    my $target = '_metcall_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $method,
			       $arg_string), $met_type, undef, $met_units;
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _metcall_code_perl {

    my ($class, $context, $node, $subtype, $var_expr, $method, $met_sig,
	$arg_string) = @_;
    
    return $var_expr . '->' . $method . '(' . $arg_string . ')';
}


#=============================================================================
# 
# Next, the base class for the rest of the Mad class hierarchy.
#
#    ExtClass
# 
# This class is purely virtual, existing only to provide methods to its
# subclasses.

package Mad::Gen::ExtClass;


# Return information about the attributes that this class supports.  In this
# case: none.  Subclasses will typically override this method to indicate that
# they support attributes.

sub _attrs {
    return {}, [];
}

sub _methods {
    return {};
}

# Generate code to declare a variable whose type is a subclass of ExtClass.

sub _declare_code {
    
    my ($class, $context, $node, $subtype, $var_expr, $dimlist) = @_;
    
    # First check that this method is not being called on class ExtClass,
    # which is a purely virtual class (i.e. it is not possible to declare a
    # variable of this class).
    
    if ( $class eq 'Mad::Gen::ExtClass' ) {
	$context->syntax_error($node, "class '$class' is purely virtual.  \
You cannot declare a variable of this type.");
	return '**ERROR**';
    }
    
    # Call the appropriate method to generate the target code, or complain if
    # no such method exists.
    
    my $target = '_declare_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $dimlist);
    }
    
    else {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _declare_code_perl {
    
    my ($class, $context, $node, $subtype, $var_expr, $dimlist) = @_;
    
    # We don't really need to declare anything for Perl, so just return the
    # variable's value.
    
    return $var_expr, $class;
}


# Generate code to initialize a variable whose type is a subclass of
# ExtClass.

sub _init_code {

    my ($class, $context, $node, $subtype, $var_expr, %arg) = @_;
    my ($ah, $init_list) = $class->_attrs();
    my (@args);
    
    # First, go through the list of attributes defined for this class, and see
    # which of them (if any) have been specified in the current call.
    
    my ($p_count) = 1;
    my ($arglist) = '';
    my ($units);
    
    foreach my $a (@$init_list) {
	
	my ($arg_expr, $arg_type, $arg_dim, $arg_units);
	
	# Skip those which cannot be included in an initialization.
	
	next unless $ah->{$a}{can_init};
	
	# If a value has been specified for this attribute, include it in the
	# growing argument list.  If no value was provided, use the default
	# value.
	
	if ( ref $arg{$a} )
	{
	    ($arg_expr, $arg_type, $arg_dim, $arg_units) =
		$context->evaluate($arg{$a}, 'root');

	    my ($param_type) = $ah->{$a}{type};
	    my ($param_units) = $ah->{$a}{units};
	    
	    $param_type = $subtype if $param_type eq '@';
	    $param_units = $node->{units} if $param_units eq '@';
	    $units = $param_units if $a eq 'value';
	    
	    $context->check_units($node, $param_units, $arg_units, $p_count);
	    $context->check_types($node, $param_type, $arg_type, '=', $p_count);
	    $arg_expr = $context->transform_type($arg_expr, $arg_type, $param_type);
	}
	
	# If neither a value nor a default value is available, skip this
	# attribute.
	
	elsif ( !defined $ah->{$a}{default} or $ah->{$a}{default} eq '' )
	{
	    next;
	}
	
	# However, if the default value is '*' but no argument was provided then
	# complain.
	
	elsif ( $ah->{$a}{default} eq '*' )
	{
	    $context->syntax_error($node, "$class: attribute '$a' is required");
	    return '**ERROR**';
	}
	
	# If the default is something else, then use it.
	
	else
	{
	    $arg_type = $ah->{$a}{type};
	    $arg_expr = $ah->{$a}{default};
	    $arg_expr = "'$arg_expr'" if $arg_type eq 'Mad::Gen::string';
	    $units = $ah->{$a}{units} eq '@' ? $node->{units} : $ah->{$a}{units};
	}
	
	# Now check the argument type and units against those of the
	# corresponding parameter.
	
	# Add the ability to override the initial value.
	
	if ( $a eq 'value' )
	{
	    if ( $context->{target} eq 'perl' )
	    {
		$arg_expr = '(' . $context->generate_init_expr($node) . ' || ' .
		    $arg_expr . ')';
	    }
	}
	
	# Add the value to the argument list, and delete it from the raw
	# argument hash.
	
	$arglist .= ', ' if $arglist ne '';
	$arglist .= $arg_expr;
	$p_count++;
	delete $arg{$a};
    }
    
    # If any attributes are still in the raw argument hash at this point,
    # complain.
    
    if ( keys %arg ) {
	foreach my $bad (keys %arg) {
	    $context->syntax_error($node, "$class: unknown attribute '$bad'");
	}
	return '**ERROR**';
    }
    
    # Now call the appropriate method to generate the target code, or complain
    # if no such method exists.
    
    my $target = '_init_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $arglist);
    }
    
    else {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _init_code_perl {
    my ($class, $context, $node, $subtype, $var_expr, $argstring) = @_;
    
    # Generate code to create a new object in the class.
    
    return $var_expr . " = $class" . "->new('$argstring')";
}


sub _init_code_cc {
    my ($class, $context, $node, $subtype, $var_expr, @args) = @_;
    my $arglist = join(', ', @args);
    
    return "$class $var_expr ($arglist)";
}


# Generate code to set the value of a specified attribute of an object whose
# class is a subclass of 'ExtClass'.  If the attribute is 'value', then the
# primary value is set.

sub _set_code {
    my ($class, $context, $node, $subtype, $var_expr, $attr, $op, $value_node) = @_;
    my ($ah) = $class->_attrs();
    
    # First check the attribute, to see if it is one that we are allowed to
    # set. 
    
    unless ( exists $ah->{$attr} ) {
	$context->syntax_error($node, "$class: unknown attribute '$attr'");
	return '**ERROR**';
    }
    
    unless ( $ah->{$attr}{can_set} ) {
	$context->syntax_error($node, "$class: cannot set attribute '$attr'");
	return '**ERROR**';
    }
    
    # We can't bind any of the attributes of one of these objects, only the
    # entire thing.
    
    if ( $op eq ':=' and $attr ne '' )
    {
	$context->syntax_error($node, "$class: cannot bind an attribute to another object");
    }
    
    # Decide whether we are setting the value or binding the name.
    
    my ($select) = $op eq ':=' ? 'bind' : 'root';
    
    # Now generate the value expression and check its type.
    
    my ($value_expr, $value_type, $value_dim, $value_units) =
	$context->evaluate($value_node, $select);
    
    my ($attr_type) = $ah->{$attr}{type};
    my ($attr_units) = $ah->{$attr}{units};
    $attr_type = $subtype if $attr_type eq '@';
    $attr_units = $node->{units} if $attr_units eq '@';
    
    $context->check_units($node, $attr_units, $value_units, $attr); 
    $context->check_types($node, $attr_type, $value_type, $op, $attr);
    $value_expr = $context->transform_type($value_expr, $value_type, $attr_type);
    
    # If a method exists to generate code for the specified target, call it.
    # Otherwise, complain.
    
    my $target = '_set_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $attr,
			       $op, $value_expr), 
		       $attr_type, $value_dim, $attr_units;
    }
    
    else {
	$context->syntax_error($node, "$class: cannot compile to $target");
	return '**ERROR**';
    }
}


sub _set_code_perl {
    my ($class, $context, $node, $subtype, $var_expr, $attr, $op, 
	$value_expr) = @_;
    
    # If we are binding, we change where $var_expr points.
    
    if ( $op eq ':=' )
    {
	return $var_expr . ' = ' . $value_expr;
    }
    
    # Otherwise, we change the value of the indicated attribute.
    
    else
    {
	return $var_expr . '->{' . $attr . "} $op $value_expr";
    }
}


sub _set_code_cc {
    my ($class, $context, $node, $subtype, $var_expr, $attr, $op, $value_expr) = @_;
    
    return "$var_expr.$attr $op $value_expr";
}


# Generate code to get the value of a specified attribute of an object whose
# class is a subclass of 'ExtClass'.  If the attribute is 'value', then
# the primary value of the object is returned.

sub _value_code {
    my ($class, $context, $node, $subtype, $var_expr, $attr) = @_;
    my ($ah) = $class->_attrs();
    
    # First check the attribute, to see if it is one that we are allowed to
    # query.
    
    unless ( exists $ah->{$attr} ) {
	$context->syntax_error($node, "$class: unknown attribute '$attr'");
	return '**ERROR**';
    }
    
    unless ( $ah->{$attr}{can_get} ) {
	$context->syntax_error($node, "$class: cannot get attribute '$attr'");
	return '**ERROR**';
    }
    
    # Then determine the type and units.
    
    my ($value_type) = $ah->{$attr}{type};
    my ($value_units) = $ah->{$attr}{units};
    $value_type = $subtype if $value_type eq '@';
    $value_units = $node->{units} if $value_units eq '@';
    
    # If a method exists to generate code for the specified target, call it.
    # Otherwise, complain.
    
    my $target = '_value_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $attr),
	    $value_type, undef, $value_units;
    }
    
    else {
	$context->syntax_error($node, "$class: cannot compile to $target");
	return '**ERROR**';
    }
}


sub _value_code_perl {
    my ($class, $context, $node, $subtype, $var_expr, $attr) = @_;
    
    return $var_expr . '->{' . $attr . '}';
}


sub _value_code_cc {
    my ($class, $context, $node, $subtype, $var_expr, $attr) = @_;
    
    return "$var_expr.$attr";
}


# Return true if this type can be used in a context that requires a value.
# True for subtypes of this class that define an attribute called 'value'.

sub _has_value {

    my ($class) = shift @_;
    my ($ah) = $class->_attrs();
    return exists $ah->{'value'};
}


# Generate code that will execute a method call on an object whose class is a
# subclass of 'Base'.

sub _metcall_code {
    my ($class, $context, $node, $subtype, $var_expr, $method, @args) = @_;
    my ($mh) = $class->_methods();
    
    # First check the method name, to see if this class actually implements
    # it.
    
    unless ( $class->can($method) ) {
	$context->syntax_error($node, "$class: unknown method '$method'");
	return '**ERROR**';
    }
    
    # Then evaluate the parameters and check type and units.
    
    my (@signature) = @{$mh->{$method}{sig}} if exists $mh->{$method}{sig};
    
    my ($arg_string) = '';
    my ($p_count) = 1;
    
    foreach my $n ( @args )
    {
	my ($arg_expr, $arg_type, $arg_dim, $arg_units) = 
	    $context->evaluate($n, 'root');
	
	unless ( @signature )
	{
	    $context->syntax_error($node, "too many parameters for method '$method'");
	    return '**ERROR**';
	}
	
	my $p_type = shift @signature;
	my $p_units = shift @signature;
	$p_type = $subtype if $p_type eq '@';
	$p_units = $node->{units} if $p_units eq '@';
	
	$context->check_types($node, $p_type, $arg_type, '=', $p_count);
	$context->check_units($node, $p_units, $arg_units, $p_count);
	
	$arg_string .= ', ' if $arg_string;
	$arg_string .= $arg_expr;
	$p_count++;
    }
    
    # Then determine the type and units of the method result.
    
    my ($met_type) = $mh->{$method}{type};
    my ($met_units) = $mh->{$method}{units};
    $met_type = $subtype if $met_type eq '@';
    $met_units = $node->{units} if $met_units eq '@';
    
    # Finally, call the appropriate method to generate the target code.
    
    my $target = '_metcall_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $var_expr, $method,
			       $arg_string),
	    $met_type, undef, $met_units;
    }
    
    else {
	$context->syntax_error($node, "$class: cannot compile to $target");
	return '**ERROR**';
    }
}


sub _metcall_code_perl {
    my ($class, $context, $node, $subtype, $var_expr, $method, 
	$arg_string) = @_;
    
    return $var_expr . '->' . $method . '(' . $arg_string . ')';
}


sub _metcall_code_cc {
    my ($class, $context, $node, $subtype, $var_expr, $method, 
	$arg_string) = @_;
    
    return "$var_expr.$method($arg_string)";
}


#=============================================================================
# 
# The most important subclass of ExtClass is the base class for flow
# endpoints:
#
#    BaseValue
# 
# This class supports a single unbounded value, which can be augmented or
# diminished by means of flows.  Its implementation is very simple, and
# designed for maximum reusability by subclasses.
# 
# This class also supports one regular method: new.  The C++ equivalent is
# defined in Standard.c.  This method is designed to be general enough to be
# inheritable by most if not all flow endpoint classes.

package Mad::Gen::BaseValue;
@Mad::Gen::BaseValue::ISA = ('Mad::Gen::ExtClass');

# Return information about the attributes this class supports.

my $attr_hash = { value => { type => 'Mad::Gen::num', 
			     units => '@',
			     default => '0.0',
			     can_init => 1, 
			     can_get => 1, 
			     can_set => 1} };
my $init_list = ['value'];

sub _attrs {
    return $attr_hash, $init_list;
}

my $met_hash = { new => { type => 'Mad::Gen::BaseValue',
			  sig => ['Mad::Gen::num'] } };

sub _methods {
    return $met_hash;
}


# Generate code to compute the rate of a proportional flow to or from this
# endpoint.

sub _prop_rate_code {
    my ($class, $context, $node, $subtype, $var_expr, $rate_node) = @_;
    
    my ($value_expr) = $class->_value_code($context, $node, $subtype, $var_expr,
					   'value');
    
    my ($rate_expr, $rate_type, $rate_dim, $coef_units);
    
    # Call the appropriate method to generate the target code.
    
    my $target = '_prop_rate_' . $context->{target};
    
    if ( $class->can($target) )
    {
	($rate_expr, $rate_type, $rate_dim, $coef_units) = 
	    $class->$target($context, $node, $subtype, $value_expr, $rate_node);
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot compile to $target");
	return '**ERROR**';
    }
    
    # Check units.
    
    unless ( !defined $coef_units or $coef_units->{'/'} or $coef_units->{'*'} )
    {
	$context->syntax_error($node, "proportional flow coefficient must be unitless");
    }
    
    return $rate_expr, $rate_type, $rate_dim, $coef_units;
}


sub _prop_rate_perl {

    my ($class, $context, $node, $subtype, $value_expr, $rate_node) = @_;
    
    # Evaluate the proportional flow coefficient
    
    my ($coef_expr, $coef_type, $coef_dim, $coef_units) =
	$context->evaluate($rate_node, '*');
    
    # Make sure that its type is primitive.  Multiplication by $var_expr is
    # sufficient to transform any of the primitive types into a numeric value
    # (in Perl).
    
    unless ( $Mad::Model::PRIMITIVE_TYPE{$coef_type} )
    {
	$context->syntax_error($node, "proportional flow coefficient must be a simple type");
    }
    
    return "$value_expr * $coef_expr", 'Mad::Gen::num', undef, $coef_units;
}


# Generate code that should be run before computing any flows to or from this
# endpoint.  For the BaseValue class, we don't need to do anything.

sub _preflow_code {
    return;
}


# Generate code to check the flow rates to and/or from this endpoint against
# boundary conditions on the endpoint, and adjust the flows as necessary.  The
# BaseValue class has no boundary conditions, so we don't have to do anything.

sub _bounds_code {
    return;
}


# Generate code to carry out flows to and from this endpoint.  The $outflows
# and $inflows parameters should be references to lists of flow records.

sub _flow_code {
    my ($class, $context, $node, $subtype, $var_expr, $outflows, $inflows) = @_;
    
    my @code;
    my $rpkg = $context->{model}{runpkg};
    my $int_expr = "\$${rpkg}I";
    
    my $target = '_flow_code_' . $context->{target};
    
    if ( defined $inflows and @$inflows > 0 )
    {
	my $inf_expr;
	my $op = '';
	
	foreach my $flow ( @$inflows ) {
	    $inf_expr .= $op . $flow->{expr};
	    $op = ' + ';
	}
	
	if ( @$inflows > 1 )
	{
	    $inf_expr = "($inf_expr)";
	}
	
	push @code, $class->$target($context, $node, $subtype, $var_expr, 
				    '+=', "$inf_expr * $int_expr");
    }
    
    if ( defined $outflows and @$outflows > 0 ) {
	my $outf_expr;
	my $op = '';
	
	foreach my $flow ( @$outflows ) {
	    $outf_expr .= $op . $flow->{expr};
	    $op = ' + ';
	}
	
	if ( @$outflows > 1 )
	{
	    $outf_expr = "($outf_expr)";
	}
	
	push @code, $class->$target($context, $node, $subtype, $var_expr, 
				    '-=', "$outf_expr * $int_expr");
    }
    
    return @code;
}

sub _flow_code_perl {
    
    my ($class, $context, $node, $subtype, $var_expr, $op, $value_expr) = @_;
    
    return $var_expr . '->{value} ' . "$op $value_expr;";
}


# Generate code that should be run after computing the flows to or from this
# endpoint.  For the BaseValue class, we don't need to do anything.

sub _postflow_code {
    return;
}


#=============================================================================
# 
# Now subclass for flow endpoints whose value is constrained to be nonnegative:
# 
#    Mad::Gen::Pool
# 
# This is the next most basic object class for use with flows.  It encompasses
# a single numeric value that is not allowed to fall below zero.  If at any
# step the outflows would cause the value to become negative, they will be
# limited (in equal proportions if there are more than one) to rates
# sufficient to bring the value down to exactly zero.

package Mad::Gen::Pool;
@Mad::Gen::Pool::ISA = ('Mad::Gen::BaseValue');

my $attr_hash = { value => { type => 'Mad::Gen::num', 
			     units => '@',
			     default => '0.0',
			     can_init => 1, 
			     can_get => 1, 
			     can_set => 1} };
my $init_list = ['value'];

sub _attrs {
    return $attr_hash, $init_list;
}

my $met_hash = { new => { type => 'Mad::Gen::BaseValue',
			  sig => ['Mad::Gen::num'] } };

sub _methods {
    return $met_hash;
}

# Generate code to set the value of a variable of class 'Pool' or one of its
# attributes.  This method differs from that of 'BaseValue' in that whenever
# an attempt is made to set the value to less than zero, it is set to zero
# instead.

sub _set_code_perl {
    my ($class, $context, $node, $subtype, $var_expr, $attr, $op, 
	$value_expr) = @_;
    
    # If we are binding, we change where $var_expr points.
    
    if ( $op eq ':=' )
    {
	return $var_expr . ' = ' . $value_expr;
    }
    
    # Otherwise, we change the value of the indicated attribute.
    
    else
    {
	return $var_expr . '->{' . $attr . "} $op $value_expr; $var_expr" .
	    '->{value} = 0 if ' . $var_expr . '->{value} < 0';
    }
}


sub _set_code_cc {
    my ($class, $context, $node, $subtype, $var_expr, $dummy, $op, $value_expr) = @_;
    
    return "$var_expr.value $op $value_expr; $var_expr.value = 0 if \
$var_expr.value < 0";
}


# Generate code to make sure that the flows into and out of the given object
# do not make its value go below zero.

sub _bounds_code {
    my ($class, $context, $node, $subtype, $var_expr, $outflows, $inflows) = @_;
    
    # Don't do anything unless there actually are outflows
    
    if ( !defined $outflows or @$outflows == 0 ) {
	return;
    }
    
    # If there is a method to generate code for $target, call that.
    # Otherwise, complain.
    
    my $target = '_bounds_code_' . $context->{target};
    
    if ( $class->can($target) ) {
	return $class->$target($context, $node, $subtype, $var_expr, 
			       $outflows, $inflows);
    }
    else {
	$context->syntax_error($node, "$class: cannot compile to $target");
	return '**ERROR**';
    }
}


sub _bounds_code_perl {
    my ($class, $context, $node, $subtype, $var_expr, $outflows, $inflows) = @_;
    
    # THIS NEEDS WORK! $$$$
    
    return;
    
    # Compare outflows to value
    # If outflows are less, nothing needs to be done
    # Otherwise, compare outflows to value + inflows
    # If outflows are less, add this endpoint to the "potential adjust" list
    # Otherwise, reduce outflows proportionally and add this endpoint to
    #    the "pa" list.
    
    if ( @$outflows == 1 ) {
	
	my $flow_expr = Mad::Gen::Flow->_value_code('perl', $context,
						     $outflows->[0]{name});
	
	
	
	

	#return '    $' . $flow_name . ' = ' . $basevar . '->{value} if $' . $flow_name .
	 #   ' > ' . $basevar . "->{value};\n";
    }
    
    # Otherwise, construct the sum of all of the flow rates
    
    my $sum = '';
    my $op = '';
    
    foreach my $flowrec ( @$outflows ) {
	$sum .= $op . '$' . $flowrec->{name};
	$op = ' + ';
    }
    
    # Now construct the checking code
    
    #my $code = '    if ( ' . $sum . ' > ' . $basevar . "->{value} ) {\n";
    #$code .= '        my $ratio = $endpoint / ( ' . $sum . " );\n";
    
    foreach my $flowrec ( @$outflows ) {
	#$code .= '        $' . $flowrec->{name} . ' *= $ratio;' . "\n";
    }
    
    #$code .= "    }\n";
    
    #return $code;
}


sub _bounds_code_cc {

}



#=============================================================================
# 
# A generalization of the Pool class that has both an upper and a lower bound.
# 
#    Mad::Gen::Reservoir
# 
# If at any step the inflows and outflows would cause the value to drop below
# the lower bound, the outflows will be limited (in equal proportions if there
# are more than one) to rates sufficient to bring the value down to exactly
# zero.  If the Reservoir is to have an upper bound, it must also have a
# special outflow tagged 'overflow'.  If the inflows and outflows would cause
# the value to rise above the upper bound, the excess is directed to the
# overflow.

package Mad::Gen::Reservoir;
@Mad::Gen::Reservoir::ISA = ('Mad::Gen::BaseValue');

my $attr_hash = { value => { type => 'Mad::Gen::num', 
			     default => 0.0,
			     can_init => 1, 
			     can_get => 1, 
			     can_set => 1 },
		  lowerbound => { type => 'Mad::Gen::num',
				  default => 0.0,
				  can_init => 1,
				  can_get => 1,
				  can_set => 1 },
		  upperbound => { type => 'Mad::Gen::num',
				  default => '',
				  can_init => 1,
				  can_get => 1,
				  can_set => 1 } };

my $init_list = ['value', 'lowerbound', 'upperbound'];

sub _attrs {
    return $attr_hash, $init_list;
}

my $met_hash = { new => { type => 'void',
			  sig => ['Mad::Gen::num', '@',
				  'Mad::Gen::num', '@',
				  'Mad::Gen::num', '@'] } };

sub _methods {
    return $met_hash;
}


sub _set_code_perl {
    my ($class, $context, $node, $subtype, $var_expr, $attr, $op, $value_expr) = @_;
    
    if ( $attr eq 'value' ) {
	return $var_expr . '->{value} = ' . $value_expr . '; ' . 
	    $var_expr . '->{value} = ' . $var_expr . '->{upperbound} if ' . 
		$var_expr . '->{value} > ' . $var_expr . '->{upperbound}' . '; ' .
		    $var_expr . '->{value} = ' . $var_expr . '->{lowerbound} if ' .
			$var_expr . '->{value} < ' . $var_expr . '->{lowerbound}';
    }
}


#=============================================================================
# 
# A class whose members represent infinite sources or sinks.
# 
#    Mad::Gen::PseudoVar
# 
# Objects of this class have no defined value; rather, their value represents
# the net of outflow and inflow.

# $$$$ NEEDS REVIEW

package Mad::Gen::PseudoVar;


# Generate code to declare a variable of class 'Mad::Gen::PseudoVar'.

sub _declare_code {

    my ($class, $context, $node, $subtype, $var_expr, $dimlist) = @_;
    
    # Call the appropriate method to generate the target code, or complain
    # if no such method exists.
    
    my $target = '_declare_code_' . $context->{target};
    
    if ( $class->can($target) ) {
	return $class->$target($context, $node, $subtype, $var_expr, $dimlist),
	    $class;
    }
    else {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}

# Since such variables don't really need to be declared in Perl, we just
# return the variable's name.

sub _declare_code_perl {

    my ($class, $context, $node, $subtype, $var_expr, $dimlist) = @_;
    
    return $var_expr;
}


# Generate code to initialize a variable of class 'Mad::Gen::PseudoVar'.  Note
# that a Pseudo-variable has no attributes.

sub _init_code {

    my ($class, $context, $node, $subtype, $var_expr, @attrs) = @_;
    
    # Complain if any attributes were given.
    
    if ( @attrs )
    {
	$context->syntax_error($node, "you cannot specify any attributes for a pseudo-variable");
    }
    
    # Call the appropriate method to generate the target code, or complain
    # if no such method exists.
    
    my $target = '_init_code_' . $context->{target};
    
    if ( $class->can($target) ) {
	return $class->$target($context, $node, $subtype, $var_expr);
    }
    else {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}

sub _init_code_perl {

    my ($class, $context, $node, $subtype, $var_expr) = @_;
    
    return "$var_expr = $class" . "->new()";
}


# Generate code to get the net value (i.e. of inflow over outflow) of a variable
# of class 'PseudoVar'.

sub _value_code {
    my ($class, $context, $node, $subtype, $var_expr, $attr) = @_;
    
    # First check the attribute, to see if it is one that we are allowed to
    # query. 
    
    unless ( $attr eq 'value' ) {
	$context->syntax_error($node, "$class: unknown attribute '$attr'");
	return '**ERROR**';
    }
    
    # If a method exists to generate code for the specified target, call it.
    # Otherwise, complain.
    
    my $target = '_value_code_' . $context->{target};
    
    if ( $class->can($target) ) {
	return $class->$target($context, $node, $subtype, $var_expr, 'value');
    }
    else {
	$context->syntax_error($node, "$class: cannot compile to $target");
	return '**ERROR**';
    }
}


sub _value_code_perl {
    my ($class, $context, $node, $subtype, $var_expr) = @_;
    
    return $var_expr . "->{net}";
}


sub _value_code_cc {
    my ($class, $context, $node, $subtype, $var_expr) = @_;
    
    return "$var_expr.net";
}


# Setting the value of a PseudoVar is not allowed.

sub _set_code {
    my ($class, $context, $node, $subtype) = @_;
    
    $context->syntax_error($node, "you cannot set the value of a pseudo-variable");
    return '**ERROR**';
}


sub _prop_rate_code {
    my ($class, $context, $node, $subtype) = @_;

    $context->syntax_error($node, "You cannot use a proportional rate with a \
pseudo-variable");
    return '**ERROR**';
}


sub _preflow_code {
    return '';
}


sub _bounds_code {
    return;
}


sub _flow_code {
    my ($class, $context, $node, $subtype, $basevar, $outflows, $inflows) = @_;
    
    if ( ref $inflows and @$inflows > 0 ) {
	my $code = '    ' . $basevar . '->{net}';
	my $op = ' -= ';
    
	foreach my $flow ( @$inflows ) {
	    $code .= $op . '$' . $flow->{name};
	    $op = ' - ';
	}
	
	$code .= ";\n";
    }
    
    if ( ref $inflows and @$outflows > 0 ) {
	#$code .= '    ' . $basevar . '->{net}';
	#$op = ' += ';
	
	foreach my $flow ( @$outflows )  {
	#    $code .= $op . '$' . $flow->{name};
	#    $op = ' + ';
	}
	
	#$code .= ";\n";
    }
    
    #return $code;
}


sub _postflow_code {
    return '';
}


# Following are the ordinary object methods defined for this class.
# -----------------------------------------------------------------

# Create a new object in this clas.

sub new {
    my $class = shift;
    my $newobj = { net => 0.0 };
    
    return bless $newobj, $class;
}


#=============================================================================
# 
# The class representing flows.
# 
#    Mad::Gen::Flow
# 
# The flows tie together endpoints.

# $$$$ NEEDS WORK

package Mad::Gen::Flow;


# Generate code to declare a flow.

sub _declare_code {
    
    my ($class, $context, $node, $subtype, $flow_name) = @_;
    
    # We call the appropriate method to generate the target code, or
    # complain if no such method exists.
    
    my $target = '_declare_code_' . $context->{target};
    
    if ( $class->can($target) )
    {
	return $class->$target($context, $node, $subtype, $flow_name);
    }
    
    else
    {
	$context->syntax_error($node, "$class: cannot be compiled to $target");
	return '**ERROR**';
    }
}


sub _declare_code_perl {

    my ($class, $context, $node, $subtype, $flow_name) = @_;
    
    # We don't really need to declare anything for Perl, so just return the
    # variable's name.
    
    my ($runpkg) = $context->{model}{runpkg};
    
    return '$' . $runpkg . $flow_name, $class;
}


sub _value_code {

}


sub _set_code {

}


1;
