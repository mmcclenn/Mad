#
# NBGC Project
# 
# Class NBGC::Model - dynamic system model
# 
# Author: Michael McClennen
# Copyright (c) 2010 University of Wisconsin-Madison
# 
# Each instance of this class represents a dynamic system model.  The model
# expresses a system of differential equations by means of a set of variables
# and flows.  An approximate solution to this system of equations can then be
# generated by iteration over a series of time steps.  This is referred to as
# "running" the model.


package Mad::Model;

use strict;
use warnings;
use Carp;
use Exporter qw( import );



our ($RUNPKG) = 0;

our(%BASE_TYPE) = ('SCALARV' => 'Mad::Gen::Scalar',
		   'LISTV' => 'Mad::Gen::List',
		   'SETV' => 'Mad::Gen::Set',
		   'PVAR' => 'Mad::Gen::Pseudo');

our(%PRIMITIVE_TYPE) = ( 'Mad::Gen::num' => 1,
			 'Mad::Gen::int' => 1,
			 'Mad::Gen::flag' => 1,
			 'Mad::Gen::string' => 1,
			 'Mad::Gen::general' => 1,
			 'num' => 1,
			 'int' => 1,
			 'flag' => 1,
			 'string' => 1,
			 'general' => 1 );

our (%LIST_TYPE) = ( 'Mad::Gen::List' => 1,
		     'Mad::Gen::Set' => 1 );

our (%INIT_TARGET) = ();

use Mad::Parser;
use Mad::Standard;
use Mad::Context;
use Mad::Units;
use Mad::Gen_code;
use Mad::Gen_cc;

#use Data::Dumper;


# Constructor, destructor and related methods
# ===========================================

# new ( )
# 
# Creates a new Model instance.

sub new {

    my ($class) = @_;
    
    # Create a new object and bless it into the proper class.
    
    my $self = {};
    bless $self, $class;    
    
    # Create a parser object, and link it to this model.
    
    $self->{parser} = new Mad::Parser;
    $self->{parser}->init($self);
    
    $self->{parser}{declare_struct} = \&declare_struct;
    $self->{parser}{declare_member} = \&declare_member;
    $self->{parser}{declare_funct} = \&declare_funct;
    $self->{parser}{declare_static} = \&declare_static;
    
    # The field 'status' records the current status of the model, vis-a-vis
    # compiling and running.  Other statuses include 'LOAD_ERROR', 'READY',
    # 'INITIALIZED', 'RUNNING', 'STOPPED', 'RUN_ERROR', etc.
    
    $self->{status} = 'EMPTY';
    $self->{error_count} = 0;
    
    # Create symbol tables for classes, global variables, dimensions and
    # functions in package "main".
    
    $self->{static}{main} = Mad::Symtab->new();
    $self->{struct}{main} = Mad::Symtab->new();
    $self->{funct}{main} = Mad::Symtab->new();
    $self->{dim}{main} = Mad::Symtab->new();
    
    # Dimension ID generator
    
    $self->{dim_id} = 1;
    
    # Variable and flow tables
    
    $self->{varlist} = [];
    $self->{flowlist} = [];
    
    $self->{flowname} = { 'flow' => 1 };
    $self->{pointtab} = {};
    $self->{pointlist} = [];
    $self->{sourcetab} = {};
    $self->{sinktab} = {};
    
    # Set up the tables of common units.
    
    $self->setup_units();
    
    # Set up the common functions.
    
    $self->setup_functions();
    
    return $self;
}


# DESTROY ()
# 
# Empty destructor method

sub DESTROY {
}


# Methods for loading and generating code
# ------------------------

# load_mad ( $filename )
# 
# Load a stream of Mad code into the model.  This involves parsing the code
# and compiling it into some other language, i.e. Perl or C++.  The $filename
# argument specifies the source of the code, and the target language is
# specified by $target.
# 
# This method returns a true value if no errors were found, false otherwise.

sub load_mad {
    
    my ($self, $filename) = @_;
    
    # We start by initializing the parser, which includes telling it from
    # where to read the code.
    
    $self->{error_count} = 0;
    
    my $parser = $self->{parser};
    $parser->parse_input($filename);
    
    my $lexer = $main::DEBUG_LEVEL > 0 ? \&Mad::Parser::my_lex_wrapper :
					 \&Mad::Parser::my_lexer;
    
    my $debugflags = $main::DEBUG_LEVEL > 0 ? 0x05 : 0x00;
    
    # Now parse the code whose source was specified above by $filename.
    
    my $tree = $parser->YYParse( yylex => $lexer, 
				 yyerror => \&Mad::Parser::syntax_error, 
				 yybuildingtree => 1, yydebug => $debugflags);
    
    $self->{parse_tree} = $tree;
    $self->{error_count} += $parser->YYNberr();
    
    $self->{implicit_index} = $main::IMPLICIT_INDEX;
    
    # If any errors occurred, we note this and return.
    
    if ( $self->{error_count} > 0 ) {
	$self->{status} = 'LOAD_ERROR';
    }
}


# syntax_error ( $node, $msg )
# 
# Signal that an error has occurred.  If given, $node provides the
# file name and line number with which the error is associated.

sub syntax_error {

    my ($self, $node, $msg) = @_;
    
    if ( $node ) {
	print STDERR "Syntax error at line $node->{line} of $node->{filename}: $msg\n";
    }
    else {
	print STDERR "Syntax error: $msg\n";
    }
    
    $self->{error_count}++;
}


my %DECL_ERROR_TRANS = ( 'CLASS' => 'class', 
			 'STRUCT' => 'struct',
			 'DYN_VAR' => 'variable',
			 'CALC_VAR' => 'variable',
			 'ASSIGN_VAR' => 'variable',
			 'ATTR' => 'attribute',
			 'PARAM_VAR' => 'parameter', 
			 'CONST_VAR' => 'constant');

# decl_error ( $node )
# 
# Signal that an error has occurred because the declaration given by $node
# conflicts with a previous declaration.

sub decl_error {
    
    my ($self, $node, $name, $old_rec) = @_;
    
    my $word = $DECL_ERROR_TRANS{$old_rec->{kind}} || 'variable';
    my $file = $old_rec->{decl}{filename};
    my $line = $old_rec->{decl}{line};
    
    my $filemsg = $file ne $node->{filename} ? " of $file" : '';
    
    $self->syntax_error($node, "a $word called '$name' was already defined at line $line$filemsg");
}   


# unit_error ( $node, $msg )
# 
# Signal that an error in unit-balancing was detected.  We use a separate
# routine for these so that they can be suppressed en masse if the user so
# wishes. 

sub unit_error {

    my ($self, $node, $msg) = @_;
    
    print STDERR "Unit error at line $node->{line} of $node->{filename}: $msg\n";
    $self->{error_count}++;
}


# unit_warning ( $node, $msg )
# 
# Same as unit_error, but do not increment the error count.

sub unit_warning {
    
    my ($self, $node, $msg) = @_;
    
    print STDERR "Unit warning at line $node->{line} of $node->{filename}: $msg\n";
}


# general_error ( $msg )
# 
# Signal that an error has occurred, which is not associated with a particular
# line in the program.

sub general_error {
    
    my ($self, $msg) = @_;
    
    print STDERR "Error: $msg\n";
    $self->{error_count}++;
}


# error_count ( )
# 
# Return the number of errors that have occured.

sub error_count {

    my $self = shift;
    return $self->{error_count};
}


# declare_struct ( $node, $namespace )
# 
# Adds to the model a struct declaration drawn from the parse subtree rooted
# at $node.  This declaration is placed into the given namespace.

sub declare_struct {
    my ($self, $node, $namespace) = @_;
    
    # First check if the struct name is compound.  If so, move everything before
    # the last :: to $namespace.
    
    my $name = $node->{attr};
    
    if ( $name =~ /(.*)::(.*)/ )      # first .* is greedy by default
    {
	$namespace = $1;
	$name = $2;
    }
    
    else
    {
	$namespace = 'main';
    }

    # If this struct has already been declared, signal an error.
    
    if ( exists $self->{STRUCT}{$namespace}{$name} )
    {
	my $rec = $self->{STRUCT}{$namespace}{$name};
	$self->syntax_error($node, "struct '$name' was already declared " .
			    "in namespace '$namespace' " .
			    "at line $rec->{line} of $rec->{filename}");
    }
    
    # Otherwise, create a new record to represent this struct.
    
    my $rec = { name => $name, line => $node->{line},
		filename => $node->{filename},
		mlist => [], member => {} };
    
    $self->{STRUCT}{$namespace} ||= Mad::Symtab->new();
    $self->{STRUCT}{$namespace}{$name} = $rec;
    
    # return the new record, so that members can be properly added to it.
    
    return $rec;
}


# declare_member ( $node, $struct, $namespace )
# 
# Add a data or function member to the struct described by the record $rec,
# according to the parse subtree rooted at $node.

sub declare_member {
    my ($self, $node, $rec) = @_;
    
    # First check if $name is compound.  If so, signal an error.  Member names
    # should never contain ::
    
    my $name = $node->{attr};
    
    if ( $name =~ /::/ )
    {
	$self->syntax_error("unexpected '::' in member name");
    }
    
    # If there is already a member with the given name, signal an error also.
    
    if ( exists $rec->{field}{$name} )
    {
	my $line = $rec->{field}{$name}{line};
	my $filename = $rec->{field}{$name}{filename};
	$self->syntax_error("member '$name' was already defined for this " .
			    "structure at line $line of $filename");
    }
    
    elsif ( exists $rec->{method}{$name} )
    {
	my $line = $rec->{method}{$name}{line};
	my $filename = $rec->{method}{$name}{filename};
	$self->syntax_error("member '$name' was already defined for this " .
			    "structure at line $line of $filename");
    }
    
    # Otherwise, create the new member record.  For a function, we need to
    # deal with the parameter list.
    
    if ( ref $node eq 'FUNCTION' )
    {
	my $type = $node->{children}[0]{attr};
	my @plist = @{$node->{children}[1]{children}};
	foreach my $i (@plist)
	{
	    $i = $i->{attr};
	}
	
	$rec->{method}{$name} = { name => $name, kind => 'METHOD', 
				  plist => \@plist, type => $type, 
				  line => $node->{line},
				  filename => $node->{filename} };
    }
    
    # For a data member, the node may actually specify more than one of them.
    
    else
    {
	my $num_members = $#{$node->{children}};
	my $type = $node->{children}[-1]{attr};
	
	for ( my $i = 0; $i < $num_members; $i++ )
	{
	    my $cn = $node->{children}[$i];
	    
	    $rec->{field}{$name} = { name => $cn->{attr}, kind => 'FIELD',
				     type => $type, line => $cn->{line},
				     filename => $cn->{filename} };
	}
    }
}


# declare_funct ( $node, $namespace )
# 
# Add a function to the model, from the parse tree rooted at $node.  Place
# this function in the namespace $namespace.

sub declare_funct {
    my ($self, $node, $namespace) = @_;
    
    my $name = $node->{attr};
    my $rec;
    
    $namespace = 'main' unless $namespace;
    
    # First extract the information needed to declare this function.

    my $type = $node->{children}[0]{attr};
    my @plist = @{$node->{children}[1]{children}};
    foreach my $i (@plist)
    {
	$i = $i->{attr};
    }
    
    # Then check if the function name is compound.  If so, move everything before
    # the last :: to $namespace.
    
    if ( $name =~ /(.*)::(.*)/ )      # first .* is greedy by default
    {
	$namespace .= '::' . $1;
	$name = $2;
	
	# Check to see if the last component of the namespace is the name of a
	# struct.  If so, we're adding a new data member.
	
	if ( $namespace =~ /(.*)::(.*)/ && ($rec = $self->{struct}{$1}{$2}) )
	{
	    $rec->{method}{$name} = { name => $name, kind => 'METHOD', 
				      plist => \@plist, type => $type, 
				      line => $node->{line},
				      filename => $node->{filename} };
	    return;
	}
    }
    
    # Otherwise, we're declaring a function independent of any class.
    
    else
    {
	$self->{FUNCT}{$namespace} ||= Mad::Symtab->new();
	$self->{FUNCT}{$namespace}{$name} = 
	  { name => $name, kind => 'FUNCTION', plist => \@plist,
	    type => $type, line => $node->{line}, 
	    filename => $node->{filename} };
    }
}


# declare_static ( $node, $namespace )
# 
# Add one or more static variables to the model, according to the parse
# subtree rooted at $node.

sub declare_static {
    my ($self, $node, $namespace) = @_;
    
    my $num_vars = $#{$node->{children}};
    my $type = $node->{children}[-1]{attr};
    
    # All of the node's children except the last represent variables to
    # declare.  The last one represents the type.
    
    for ( my $i = 0; $i < $num_vars; $i++ )
    {
	my $cn = $node->{children}[$i];
	my $name = $cn->{attr};
	
	# If the name is compound, it represents a variable in another
	# namespace.
	
	if ( $name =~ /(.*)::(.*)/ )
	{
	    $namespace = $1;
	    $name = $2;
	}
	
	$self->{STATIC}{$namespace} ||= Mad::Symtab->new();
	$self->{STATIC}{$namespace} = { name => $name, kind => 'STATIC',
				 type => $type, line => $cn->{line},
				 filename => $cn->{filename} };
    }
}


# see_package ( $namespace )
# 
# $$$ is this necessary?

sub see_package {

    my ($self, $namespace) = @_;
    my $pkgname = "static_$namespace";
    
    $self->{$pkgname} ||= Mad::Symtab->new();
}


# define_static ( $name, $value, $namespace )
# 
# Create a new symbol table entry for a static variable.  If $namespace is not
# given, we default to the main one.

sub define_static {
    
    my ($self, $name, $value, $namespace) = @_;
    
    # Check to make sure that what we are assigning is indeed a proper symbol
    # record. 
    
    unless ( ref $value eq 'HASH' and exists $value->{kind} ) {
	die "improper symbol record";
    }
    
    # Then figure out the appropriate symbol table and create the entry.
    
    my $table_name = $namespace ? "static_$namespace" : "static";
    
    $self->{$table_name}{$name} = $value;
}

    
# lookup_static ( $symbol, $namespace )
# 
# Look up the given symbol in the given namespace from among the static
# namespaces defined for this model.  If no namespace is given, use the main
# one by default.  If the symbol exists, return its value.  Otherwise, return
# the undefined value (false).

sub lookup_static {

    my ($self, $symbol, $namespace) = @_;
    
    my $table_name = $namespace ? "static_$namespace" : "static";
    
    $symbol =~ s/^Mad::Gen:://;
    
    if ( exists $self->{$table_name}{$symbol} ) {
	return $self->{$table_name}{$symbol};
    }
    
    else {
	return undef;
    }
}


# define_dimension ( $name, $value, $namespace )
# 
# Create a new entry in the dimension table for the given namespace.

sub define_dimension {

    my ($self, $name, $value, $namespace) = @_;

    # Check to make sure that what we are assigning is indeed a proper symbol
    # record. 
    
    unless ( ref $value eq 'HASH' and exists $value->{var_rec} ) {
	die "improper dimension record";
    }
    
    # Then figure out the appropriate symbol table and create the entry.
    
    my $table_name = $namespace ? "dim_$namespace" : "dim";
    
    $self->{$table_name}{$name} = $value;
}

    
# lookup_dimension ( $symbol, $namespace )
# 
# Look up the given symbol in either the main dimension table defined for this
# model, or the one associated with the given namespace.

sub lookup_dimension {

    my ($self, $symbol, $namespace) = @_;
    
    my $table_name = $namespace ? "dim_$namespace" : "dim";
    
    if ( exists $self->{$table_name}{$symbol} ) {
	return $self->{$table_name}{$symbol};
    }
    
    else {
	return undef;
    }
}


# merge_dimlist ( $dim1, $dim2 )
# 
# Merge the two dimension lists, and return the resulting list.

sub merge_dimlist {

    my ($self, @lists) = @_;
    
    # The result is trivial if all dimension lists are empty.  So we check the
    # most common case.
    
    return undef if @lists <= 2 and !defined $lists[0] and !defined $lists[1];
    
    # Otherwise, create a new list and add each unique dimension in the two
    # input lists.
    
    my ($merge) = [];
    my (%seen);
    
    foreach my $dl ( @lists )
    {
	next unless ref $dl eq 'ARRAY';
	foreach my $n ( @$dl )
	{
	    push @$merge, $n unless $seen{$n};
	    $seen{$n} = 1;
	}
    }
    
    return $merge;
}


# has_type ( $class_name, $namespace )
# 
# Return true if the given type ($class_name) exists, false otherwise.  If
# $namespace is given, prepend $namespace to it.

sub has_type {
    
    my ($self, $type_name, $namespace) = @_;
    
    # First check for an externally defined class or primitive type.
    
    if ( $PRIMITIVE_TYPE{$type_name} )
    {
	return 'PP';
    }
    
    if ( "Mad::Gen::$type_name"->can('_declare_code') ) {
	return 'EP';
    }
    
    # Then check for an internally defined class.  If the name has a '::' in
    # it, we need to separate that out.
    
    if ( $type_name =~ /(.*)::(.*)/ ) {
	$namespace = $1;
	$type_name = $2;
    }
    
    if ( my $rec = $self->lookup_static($type_name, $namespace) ) {
	if ( $rec->{kind} eq 'CLASS' or $rec->{kind} eq 'STRUCT' ) {
	    return 'II';
	}
    }
    
    else {
	return undef;
    }
}


# has_method ( $class, $methodname )
# 
# Return true if the given class is defined in the model and the given method
# is defined for it.

sub has_method {
    
    my ($self, $class, $mname) = @_;
    
    my $class_rec = $self->lookup_static($class) or return undef;
    
    return 1 if $class_rec->{sym}{$mname}{kind} eq 'METHOD';
    return undef; # otherwise
}


# build_type ( $type_name, $node_ref )
# 
# Given a type name and the reference type of a node, return the corresponding
# base type, sub type and full type.

sub build_type {

    my ($self, $type_name, $node_ref) = @_;
    
    my ($type, $subtype, $fulltype);
    
    if ( $PRIMITIVE_TYPE{$type_name} or 
	 $node_ref eq 'LISTV' or $node_ref eq 'SETV')
    {
	$type = $BASE_TYPE{$node_ref};
	$subtype = "Mad::Gen::$type_name";
	$fulltype = "$type<$subtype>";
    }
    
    else
    {
	$fulltype = $type = "Mad::Gen::$type_name";
	$subtype = undef;
    }
    
    return $type, $subtype, $fulltype;
}


# declare_static_vars ( $node, $namespace )
# 
# Given $node, a pointer to a variable-declaration node of the parse tree, add
# all of the variables that it declares to the current model.  Note that this
# function will only be called for static declarations, not for dynamic ones
# ("my" variables).  This function is called from the initial parsing pass,
# before the start of code generation.  This ensures that variables are
# accessible even from places in the code before where they are defined.

sub declare_static_vars {

    my ($self, $node, $namespace) = @_;
    
    my $children = $node->{children};
    my $type_node = $children->[-1];
    my $type_name = $type_node->{attr};
    my $kind = $node->{kind};
    
    # First check that the type has been defined, either externally or within
    # the model.
    
    unless ( $self->has_type($type_name) ) {
	$self->syntax_error($node, "unknown type '$type_name'");
    }
    
    # Then create a record for each variable mentioned by this declaration.
    
    foreach my $n ( @$children ) {
	
	next if $n == $type_node;
	
	# Derive the basic attributes of the variable
	
	my $var_name = $n->{attr};
	my $var_units = $n->{units};
	my ($var_type, $var_subtype, $var_fulltype) =
	    $self->build_type($type_name, ref $n);
	
	# Determine its dimensions, if any.  If a dimension-list is attached
	# to the variable, iterate over its elements (children).
	
	my $var_dim = $self->declare_dims($n->{children}[0], $namespace);
	
	# If a symbol-table entry for this name already exists, signal an
	# error.
	
	my $var_rec;
	
	if ( $var_rec = $self->lookup_static($var_name, $namespace) )
	{
	    $self->decl_error($n, $var_name, $var_rec);
	    next;
	}
	
	# Otherwise, create a new symbol-table entry.
	
	$var_rec = { name => $var_name, type => $var_fulltype,
		     kind => $kind, units => $var_units, decl => $n,
		     dim => $var_dim };
	
	push @{$self->{varlist}}, $var_rec;
	$self->define_static($var_name, $var_rec, $namespace);
    }
    
    # Return the node reference, so this call can be used as the last
    # statement of a parse action.
    
    return $node;
}


# declare_dims ( $node, $namespace )
# 
# Given $node, return a vector of dimension records representing all of the
# dimensions represented by its children.

sub declare_dims {
    
    my ($self, $node, $namespace) = @_;
    
    # If $node is not actually a dimension list, abort.
    
    return unless ref $node eq 'DIMLIST';
    
    # Otherwise, iterate through the dimensions
    
    my @dimlist;
    
    foreach my $dn (@{$node->{children}})
    {
	# For a dimension that is a set, check to see whether it has been
	# registered in the global dimension table.
	
	if ( ref $dn eq 'SETV' )
	{
	    my $dim_name = $dn->{attr};
	    my $setv_rec = $self->lookup_static($dim_name, $namespace);
	    my $dim_rec;
	    
	    unless ( ref $setv_rec and exists $setv_rec->{kind} )
	    {
		$self->syntax_error("$dim_name: not a set variable");
		return;
	    }
	    
	    unless ( $dim_rec = $self->lookup_dimension($dim_name) )
	    {
		$setv_rec->{type} =~ /<(.*)>/;
		$dim_rec = { name => $dim_name, select => 'setv', 
			     type => $1,
			     ns => $namespace, var_rec => $setv_rec };
		
		$self->define_dimension($dim_name, $dim_rec);
	    }
	    
	    push @dimlist, $dim_rec;
	}
	
	# For a dimension that is a range, or one that is a size, just create
	# an anonymous dimension record.
	
	elsif ( ref $dn eq 'RANGE' )
	{
	    my $dim_name = $self->{dim_id}++;
	    
	    $dn->{attr} =~ /(.*):(.*)/;
	    my $dim_rec = { name => $dim_name, select => 'range', 
			    type => 'Mad::Gen::int',
			    start => $1 + 0, end => $2 + 0 };
	    push @dimlist, $dim_rec;
	}
	
	else # ( ref $dim eq 'SIZE' )
	{
	    my $dim_name = $self->{dim_id}++;
	    
	    my $dim_rec = { name => $dim_name, select => 'size', 
			    type => 'Mad::Gen::int',
			    size => $dn->{attr} + 0 };
	    push @dimlist, $dim_rec;
	}
    }
    
    # Now return the list, or the undefined value if it is empty.
    
    return unless @dimlist > 0;
    return \@dimlist;
}
	

# declare_class ( $node )
# 
# Given $node, a pointer to a class-declaration node of the parse tree, add
# the class that it declares to the current model.

sub declare_class {

    my ($self, $node, $namespace) = @_;
    
    my $name = $node->{attr};
    my $kind = $node->{kind};
    my $children = $node->{children};
    
    # First check to see if a class already exists by this name.  If so,
    # signal an error.
    
    if ( $self->has_type($name) ) {
	my $rec = $self->lookup_static($name, $namespace);
	$self->decl_error($node, $name, $rec);
	return;
    }
    
    # Otherwise, create a new symbol-table entry for the class and a new
    # symbol-table for the attributes and methods associated with it.
    
    my $class_sym = Mad::Symtab->new();
    
    my $class_rec = { name => "Mad::Gen::$name", kind => $kind, decl => $node,
		      sym => $class_sym };
    
    $self->define_static($name, $class_rec, $namespace);
    $self->define_static("Mad::Gen::$name", $class_rec, $namespace);
    
    # Then populate it with the attributes and methods declared for it.
    
    foreach my $n ( @$children ) {
	
	my $nt = ref $n;
	
	# A 'DECLARE' node declares one or more attributes.
	
	if ( $nt eq 'DECLARE' ) {
	    
	    my $children = $n->{children};
	    my $type_node = $children->[-1];
	    my $type_name = $type_node->{attr};
	    
	    # First check that the type has been defined, either externally or within
	    # the model.
	    
	    unless ( $self->has_type($type_name) ) {
		$self->syntax_error($node, "unknown type or class '$type_name'");
	    }
	    
	    # Then create a record for each attribute mentioned by this
	    # declaration.
	    
	    foreach my $nn ( @$children ) {
		
		next if $nn == $type_node;
		
		my $name = $nn->{attr};
		my $units = $nn->{units};
		my ($var_type, $var_subtype, $var_fulltype) =
		    $self->build_type($type_name, ref $nn);
		
		# If this attribute already exists, signal an error.
		
		if ( $class_sym->has_sym($name) )
		{
		    my $prev_line = $class_rec->{attr}{$name}{decl}{line};
		    $self->syntax_error($nn, "'$name' was already declared in this class at line $prev_line");
		    next;
		}
		
		# Otherwise, create a new record for the attribute and add it
		# to the class record.
		
		my $attr_rec = { name => $name, kind => 'ATTR', type => $var_fulltype,
				 units => $units, decl => $nn };
		
		$class_sym->define($name, $attr_rec);
	    }
	}
	
	# A 'METHOD' node declares a method.
	
	elsif ( $nt eq 'METHOD' ) {
	    
	    my $name = $n->{attr};
	    my $type_name = $n->{children}[0]{attr};
	    my $return_ref = $n->{children}[0]{ref};
	    my $plist_node = $n->{children}[1];
	    my $units = $n->{units};
	    
	    # First check that the method's return type is valid.
	    # $$$$ we need to recognize & as indicating the return of a
	    # reference rather than a value!
	    
	    unless ( $self->has_type($type_name) or $type_name eq 'void' ) {
		$self->syntax_error($n, "unknown type or class '$type_name'");
	    }
	    
	    # If this method already exists, signal an error.
	    
	    if ( $class_sym->has_sym($name) )
	    {
		my $prev_line = $class_rec->{sym}{$name}{decl}{line};
		$self->syntax_error($n, "'$name' was already declared in this class at line $prev_line");
	    }
	    
	    # If the name contains a :: then signal an error.
	    
	    if ( $name =~ /::/ ) {
		$self->syntax_error($n, "a method name cannot contain '::'");
	    }
	    
	    # Determine the method's signature
	    
	    my (@sig) = $self->plist_signature($plist_node);
	    
	    # Create a record for the method and add it to the class
	    # declaration. 
	    
	    if ( $return_ref and $PRIMITIVE_TYPE{$type_name} )
	    {
		$type_name = "Scalar<$type_name>";
	    }
	    
	    my $method_rec = { name => $name, kind => 'METHOD', 
			       type => "Mad::Gen::$type_name", 
			       units => $units, decl => $n, sig => \@sig };
	    
	    $class_sym->define($name, $method_rec);
	}
	
	# Otherwise, we have an error.
	
	else {
	    $self->syntax_error($n, 'INTERNAL: declare_class');
	}
    }
    
    # Return the node reference, so this call can be used as the last
    # statement of a parse action.
    
    return $node;
}


# declare_method ( $node )
# 
# Given $node, a pointer to a method-declaration node of the parse tree (one
# outside of any class declaration), add the method that it declares to the
# current model.

sub declare_method {
    
    my ($self, $node) = @_;
    
    my $name = $node->{attr};
    my $type_name = $node->{children}[0]{attr};
    my $return_ref = $node->{children}[0]{ref};
    my $plist_node = $node->{children}[1];
    my $units = $node->{units};
    
    # First split up the name into a class and a method name, or signal an
    # error if this can't be done.
    
    my ($class_name, $mname);
    
    if ( $name =~ /(.*)::(.*)/ ) {	# the first '*' is greedy by default)
	$class_name = $1;
	$mname = $2;
    }
    
    else {
	$self->syntax_error($node, "method name must start with class prefix");
    }
    
    # Then check that the class has been defined already
    
    my $class_rec;
    
    unless ( $self->has_type($class_name) eq 'II' ) {
	$self->syntax_error($node, "unknown class '$class_name'");
	return;
    }
    
    else {
	$class_rec = $self->lookup_static($class_name);
    }
    
    # and that the return type is valid.
    
    unless ( $self->has_type($type_name) or $type_name eq 'void' ) {
	$self->syntax_error($node, "unknown type or class '$type_name'");
    }
    
    # Now, we examine the class's symbol table.
    
    if ( exists $class_rec->{sym}{$mname} )
    {
	my $prev_line = $class_rec->{method}{$mname}{decl}{line};
	$self->syntax_error($node, "'$name' was already declared in this class at line $prev_line");
    }
    
    # Determine the method's signature
    
    my (@sig) = $self->plist_signature($plist_node);
    
    # Create a record for the method and add it to the class
    # declaration.
    
    if ( $return_ref and $PRIMITIVE_TYPE{$type_name} )
    {
	$type_name = "Scalar<$type_name>";
    }
    
    my $method_rec = { name => $mname, kind => 'METHOD', 
		       type => "Mad::Gen::$type_name", 
		       units => $units, decl => $node, sig => \@sig };
    
    $class_rec->{sym}->define($mname, $method_rec);
    
    return $node;
}


# declare_funct ( $node, $namespace )
# 
# Add a new function to the model, using the parse subtree rooted at $node.
# This function will be placed in the namespace indicated by $namespace.  If
# the name of the function includes a '::', then this is the definition of an
# already-declared struct member function need merely be checked against the
# struct declaration.

# sub declare_funct {
#     my ($self, $node, $namespace) = @_;
    
#     # 
    
#     my $name = $node->{attr};
#     my $type_name = $node->{children}[0]{attr};
#     my $return_ref = $node->{children}[0]{ref};
#     my $plist_node = $node->{children}[1];
#     my $units = $node->{units};
    
#     # First split up the name into a class and a method name, or signal an
#     # error if this can't be done.
    
#     my ($func_name);
    
#     if ( $name =~ /(.*)::(.*)/ ) {	# the first '*' is greedy by default)
# 	$namespace = $1;
# 	$func_name = $2;
#     }
    
#     else {
# 	$func_name = $name;
#     }
    
#     # Then check that the return type is valid.
    
#     unless ( $self->has_type($type_name) or $type_name eq 'void' ) {
# 	$self->syntax_error($node, "unknown type or class '$type_name'");
#     }
    
#     # Now, we examine the global symbol table.
    
#     if ( my $rec = $self->lookup_static($func_name, $namespace) )
#     {
# 	my $filename = $rec->{decl}{filename};
# 	my $line = $rec->{decl}{line};
# 	$self->syntax_error($node, "'$name' was already declared at $filename, line $line");
#     }
    
#     # Determine the function's signature
    
#     my (@sig) = $self->plist_signature($plist_node);
    
#     # Create a record for the function and add it to the global symbol table.
    
#     if ( $return_ref and $PRIMITIVE_TYPE{$type_name} )
#     {
# 	$type_name = "Scalar<$type_name>";
#     }
    
#     my $function_rec = { name => $name, kind => 'FUNCTION', 
# 			 type => "Mad::Gen::$type_name", 
# 			 units => $units, decl => $node, sig => \@sig };
    
#     $self->define_static($name, $function_rec, $namespace);
    
#     return $node;
# }


# plist_signature ( $node )
# 
# Given a node representing the parameter list of a function or method, return
# a signature.  This is an array, of which successive pairs of elements
# represent the type and units of each parameter in turn.

sub plist_signature {

    my ($self, $plist_node) = @_;

    my (@sig);
    
    foreach my $n ( @{$plist_node->{children}} ) {
	if ( ref $n eq 'SCALARV' ) {
	    my $typename = $n->{children}[0]{attr};
	    my $is_ref = $n->{children}[0]{ref};
	    my $units = $n->{units};
	    if ( $is_ref )
	    {
		push @sig, "Mad::Gen::Scalar<Mad::Gen::$typename>", $units;
	    }
	    else
	    {
		push @sig, "Mad::Gen::$typename", $units;
	    }
	}
	elsif ( ref $n eq 'LISTV' or ref $n eq 'SETV' )
	{
	    my $type_name = $n->{children}[0]{attr};
	    my $units = $n->{units};
	    push @sig, $BASE_TYPE{ref $n} . "<$type_name>", $units;
	}
	else {
	    $self->syntax_error($plist_node, "unhandled paramter flavor '" . ref $n . "'");
	}
    }
    
    return @sig;
}


# print_tree ( )
# 
# Print out the parse tree of the most recently loaded file.

sub print_tree {
    
    my ($self) = @_;
    $self->{parser}->printout($self->{parse_tree});
}


# generate_code ( $target, $objname )
# 
# Generate code in the target language 'target', and write it to the file
# $objname.

sub generate_code {
    
    my ($self, $target, $objname) = @_;
    
    # If the target is 'perl', call the appropriate routine.
    
    if ( $target eq 'perl' )
    {
	$self->generate_code_perl($objname);
    }
    
    elsif ( $target eq 'cc' )
    {
	# $self->generate_step_cc();
	
	# $self->generate_cc('DEFAULT', 0, $tree);
	# return if $self->{error_count} > 0;
	
	# $self->generate_flow_cc($target);
	# return if $self->{error_count} > 0;
	
	# $self->generate_step_cc($target);
	# return if $self->{error_count} > 0;
	
	# $self->generate_trace_cc($target);
	# return if $self->{error_count} > 0;
	
	# $code = $self->{declare_code} . "\n\n";
	# $code .= "int init_sub ()\n{\n" . $self->{init_code} . "    return 1;\n}\n\n";
	# $code .= "int calc_sub ()\n{\n" . $self->{calc_code} . "    return 1;\n}\n\n";
	# $code .= "int step_sub ()\n{\n" . $self->{step_code} . "    return 1;\n}\n\n";
	# $code .= "int fini_sub ()\n{\n" . $self->{fini_code} . "    return 1;\n}\n\n";
	# $code .= "int trac_sub ()\n{\n" . $self->{trac_code} . "    return 1;\n}\n\n";
	# $code .= "int main () {\n}\n\n";
    }
}

    
our (%LINE_MAP) = ( USES => 'uses_code',
		    DECL => 'decl_code',
		    FUNC => 'func_code',
		    INIT => 'init_code',
		    CALC => 'calc_code',
		    STEP => 'step_code',
		    FINI => 'fini_code',
		    TRAC => 'trac_code',
		    DBGI => 'dbgi_code' );

# add_lines ( $phase, $indent, $line )
# 
# Add the given line of code to the specified phase, with the specified indent
# level (each indent level is 4 spaces).  This routine is independent of
# target language.

sub add_lines {
    
    my ($self, $phase, $indent, @lines) = @_;
    
    my $pad = "    " x $indent;
    
    foreach my $line (@lines)
    {
	$self->{$LINE_MAP{$phase}} .= "$pad$line\n";
    }
}


# annotate ( $phase, $indent, $node )
# 
# Insert an annotation into the generated code, so that the debugger will
# report any errors as coming from the source file/line number instead of the
# target file/line number.  Only do this if the annotate_target flag is on.

sub annotate {

    my ($self, $phase, $indent, $node) = @_;
    
    my $target = $self->{target};
    
    if ( $self->{annotate_target} )
    {
	if ( $target eq 'perl' ) {
	    $self->annotate_perl($phase, $indent, $node);
	}
	elsif ( $target eq 'cc' ) {
	    $self->annotate_cc($phase, $indent, $node);
	}
    }
}


# check_types_assign ( $node, $var_type, $value_type, $label )
# 
# Check whether the assignment of a value of the given type to a variable of
# the given type is allowed.  If not, signal an error using $label to indicate
# the offending element.

sub check_types_assign {

    my ($self, $node, $var_type, $value_type, $op, $label) = @_;
    
    # If one or both types are empty, abort.
    
    unless ( defined $var_type and defined $value_type )
    {
	return;
    }
    
    # If both types are identical, we're okay.
    
    if ( $var_type eq $value_type )
    {
	return;
    }
    
    # If both types are primitive, we're okay.  We can always assign one
    # primitive type to another; a transformation function will be inserted
    # where necessary by the code in the various Mad::Gen:: packages.
    
    if ( $PRIMITIVE_TYPE{$var_type} and $PRIMITIVE_TYPE{$value_type} )
    {
	return;
    }
    
    # If both types are either primitive or an array or a set of a primitive
    # type, we're okay.
    
    my ($var_subtype, $value_subtype);
    
    if ( $var_type =~ /^(.*)<(.*)>$/ )
    {
	$var_type = $1; $var_subtype = $2;
    }
    
    if ( $value_type =~ /^(.*)<(.*)>$/ )
    {
	$value_type = $1; $value_subtype = $2;
    }
    
    if ( ( $PRIMITIVE_TYPE{$var_type} or 
	   ( $LIST_TYPE{$var_type} and $PRIMITIVE_TYPE{$var_subtype} ) ) and
	 ( $PRIMITIVE_TYPE{$value_type} or
	   ( $LIST_TYPE{$value_type} and $PRIMITIVE_TYPE{$value_subtype} ) ) )
    {
	return;
    }
    
    # If we get here, at least one of the types must be a class (either Mad or
    # external.)
    
    # $$$$ need to check for subclasses!!!
    
    $self->syntax_error($node, "$label: cannot convert a value of type $value_type to $var_type");
    return;
}


# check_var ( $node, $kind )
# 
# Check that the variable represented by the given node is being used
# in a syntactically proper way.  This means that $kind, representing
# the way the variable is being used, may not conflict with the
# variable's declaration.  For example, a variable declared as
# constant cannot later be assigned to.

sub check_var {

    my ($self, $node) = @_;
    
    return;
    
    my $name = $node->{attr};
    my $kind = $node->{kind};
    my $flavor = ref $node;
    
    unless ( exists $self->{symtab}{$name} ) {
	
	unless ( $flavor eq 'PVAR' ) {
	    $self->syntax_error($node, "'$name' must be declared before use.");
	    return;
	}
	else {
	    my $var_rec = { name => $name, type => 'Mad::Gen::PseudoVar', 
			    kind => $kind, 
			    flavor => $flavor, nodelist => [ $node ] };
	    
	    push @{$self->{varlist}}, $var_rec;
	    $self->{symtab}{$name} = $var_rec;
	    return;
	}
    }
    
    my $var_rec = $self->{symtab}{$name};
    my $var_type = $var_rec->{type};
    my $var_kind = $var_rec->{kind};
    my $var_flavor = $var_rec->{flavor};
    
    if ( $flavor ne $var_flavor )
    {
	$self->syntax_error($node, "Each variable must be used as it was \
declared: as either a scalar, an array or a set.");
    }
    
    # Now check for conflicts between how the variable was defined and how it
    # is being used.
    
    if ( ($kind eq 'ASSIGN_VAR' or $kind eq 'FLOW_VAR') 
	 and $var_kind eq 'CONST_VAR' )
    {
	$self->syntax_error($node, "The variable '$name' was declared as a \
constant.");
    }
    
    if ( $kind eq 'FLOW_VAR' and not 
	 "Mad::Gen::$var_type"->can('_flow_code' ) ) {
	     
	$self->syntax_error($node, "The variable '$name' cannot be used in a \
flow.");
    }
    
    push @{$var_rec->{nodelist}}, $node;
}


# var_type ( $node )
# 
# Given a parse tree node, return the type of the variable it represents.

sub var_type {
    
    my ($self, $node) = @_;
    
    return '' unless $node;
    
    my $nt = ref $node;
    my $attr = $node->{attr};
    
    if ( $nt eq 'SCALARV' or $nt eq 'ARRAYV' or $nt eq 'SETV') {
	my $var_rec = $self->lookup_static($attr);
	my $type = $var_rec->{type};
	if ( "Mad::Gen::$type"->can('_declare_code') ) {
	    return $type;
	}
	else {
	    return 'MadClass';
	}
    }
    
    elsif ( $nt eq 'PVAR' ) {
	return 'PseudoVar';
    }
    
    else {
	croak "Unknown node type in var_type()";
    }
}


# node_attributes ( $node )
# 
# Return the set of attributes (represented by child nodes of type
# ATTR) of the given node.  This is returned as a list of alternating
# attribute, value elements with the values being parse tree nodes.

sub node_attributes {
    
    my ($self, $node) = @_;
    my @result;
    
    foreach my $n ( @{$node->{children}} ) {
	next unless ref $n eq 'ATTR';
	push @result, $n->{attr}, $n->{children}[0];
    }
    
    return @result;
}


# print_code ( )
# 
# Print out the generated code, for debugging purposes:

sub print_code {
    
    my ($self) = @_;
    
    print "\n  ==== DECL ====\n";
    print $self->{decl_code};
    print "\n  ==== INIT ====\n";
    print $self->{init_code};
    print "\n  ==== CALC ====\n";
    print $self->{calc_code};
    print "\n  ==== STEP ====\n";
    print $self->{step_code};
    print "\n  ==== FINI ====\n";
    print $self->{fini_code};
    print "\n  ==== TRAC ====\n";
    print $self->{trac_code};
    print "\n";
}
	

# see_dimenension ( $dimspec )
# 
# This function is called whenever a dimension specification is encountered,
# i.e. [%some_hash] or [1..10].  If this specification is new, then a
# "dimension record" is created and a reference to it is returned.  If it has
# been encountered before, then a reference to the existing record is
# returned.

sub see_dimension {

    my ($self, $package, $dimspec) = @_;
    
    my $key = '';
    
    foreach my $elt (@{$dimspec->{children}}) {
	if ( ref $elt eq 'ARRAYV' ) {
	    $key .= '>@';
	    $key .= $elt->{attr};
	}
	elsif ( ref $elt eq 'SETV' ) {
	    $key .= '>%';
	    $key .= $elt->{attr};
	}
	elsif ( ref $elt eq 'SCALARV' ) {
	    $key .= '>$';
	    $key .= $elt->{attr};
	}
	elsif ( ref $elt eq 'RANGE' ) {
	    $key .= '>R';
	    $key .= $elt->{attr};
	}
	elsif ( ref $elt eq 'NUM' ) {
	    $key .= '>N';
	    $key .= $elt->{attr};
	}
	elsif ( ref $elt eq 'STR' ) {
	    $key .= '>S';
	    $key .= $elt->{attr};
	}
	else {
	    $key .= '>>>';
	}
    }
    
    unless ( defined $self->{dimspec}{$key} ) {
	$self->{dimspec}{$key} = { key => $key, 
				   etc => 1 };
	$self->add_code('INIT', undef, "init_dimension('$key');");
    }
    
    my $label = $dimspec->{attr};
    
    if ( defined $label ) {
	$self->{dimspec}{$label} = $self->{dimspec}{$key};
    }
    
    return $key;
}


sub setup_functions {

    my ($self) = @_;
    
    $self->{static}{exp} = { name => 'exp', kind => 'FUNCTION', 
			     type => "Mad::Gen::num", 
			     sig => [ "Mad::Gen::num", undef ] };
}

1;
